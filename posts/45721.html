<!DOCTYPE html><html lang="zh-CN" color-mode="light"><head><link href="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/css/index.css" rel="stylesheet"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><script defer src="/_vercel/insights/script.js"></script><script defer src="/_vercel/speed-insights/script.js"></script><meta name="author" content="yxcheng"><title>Netty_NioEventLoop启动和运行 | 躺着好舒服</title><link rel="apple-touch-icon" href="/images/favicon.png"><link rel="icon" href="/images/favicon.png"><link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css"><link rel="stylesheet" href="/css/figcaption/mac-block.css"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3163875893588085" crossorigin="anonymous"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><link href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" rel="stylesheet"><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/fancybox.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-WB9L6JQGS1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-WB9L6JQGS1")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var html=document.documentElement;const colorMode=localStorage.getItem("color-mode");colorMode&&document.documentElement.setAttribute("color-mode",colorMode)</script><link rel="stylesheet" href="/css/collapse-code.css"><script src="/js/collapse-code.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="躺着好舒服" type="application/atom+xml"></head><body><div id="app"><div class="header"><div class="avatar"><a href="/"><img no-lazy src="/images/avatar.png" alt=""></a><div class="nickname"><a href="/">躺着好舒服</a></div></div><div class="navbar"><ul><li class="nav-item" data-path="/"><a href="/">首页</a></li><li class="nav-item" data-path="/tags/"><a href="/tags/">标签</a></li><li class="nav-item" data-path="/categories/"><a href="/categories/">分类</a></li><li class="nav-item" data-path="/archives/"><a href="/archives/">归档</a></li><li class="nav-item" data-path="/notes/"><a href="/notes/">Notes</a></li><li class="nav-item" data-path="/adventure/"><a href="/adventure/">冒险乐园</a></li></ul></div></div><script src="/js/activeNav.js"></script><div class="flex-container"><script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.10/dist/clipboard.min.js"></script><script src="/js/codeCopy.js"></script><div class="container post-details" id="post-details"><div class="post-content"><div class="post-title">Netty_NioEventLoop启动和运行</div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime mr-10" title="更新时间"></i> 创建时间:2022-11-30 14:49:44&nbsp; 更新时间:2025-04-21 09:14:58 &nbsp;&nbsp; </span><span><span><i class="iconfont icon-edit"></i> 9.7k 字 </span>&nbsp;&nbsp; </span><span class="post-tags"><i class="iconfont icon-tags mr-10" title="标签"></i> <span class="span--tag mr-8"><a href="/tags/netty/" title="netty">#netty&nbsp;</a></span></span></div><div class="markdown-body"><center><a style="font-style:italic" href="javascript:window.location='https://simba--cheng-cn.translate.goog/' + window.location.pathname + '?_x_tr_sl=zh-CN&amp;_x_tr_tl=en&amp;_x_tr_hl=zh-CN&amp;_x_tr_pto=wapp';">This post is also available in English and alternative languages.</a></center><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br><p>上一篇 <a href="/posts/15160.html" title="Netty_NioEventLoop创建">Netty_NioEventLoop创建</a> 大致梳理了 NioEventLoop 的创建流程，已经得知 NioEventLoop 的创建包含在 NioEventLoopGroup 的创建过程中。</p><p>本篇接着继续梳理分析 NioEventLoop 的启动和运行逻辑，值得注意的是，NioEventLoop 并不会在创建完成后立即启动和运行的。</p><blockquote><ul><li><p><font color="#D2691E">网上很多资料都将创建的 NioEventLoopGroup 对象称之为: bossGroup(boss) 和 workGroup(work)，这里OP不会这么称呼，而是采用源码中变量的命名，即: <b>parentGroup</b>和 <b>childGroup</b></font>。</p></li><li><p><font color="#FF4500">文中图片较大，懒加载，请耐心等候</font>。</p></li><li><p>本文 Netty 源码解析基于 <b>4.1.86.Final</b> 版本。</p></li><li><p>受篇幅限制，NioEventLoop 源码拆分为 <a href="/posts/15160.html" title="Netty_NioEventLoop创建">Netty_NioEventLoop创建</a> 和 <a href="/posts/45721.html" title="Netty_NioEventLoop启动和运行">Netty_NioEventLoop启动和运行</a></p></li></ul></blockquote><br><h1 id="NioEventLoop启动">1. NioEventLoop启动</h1><p>事实上，<b>NioEventLoop <u>创建&#x2F;启动工作线程</u> 的时机是在第一个任务提交时</b>。</p><ul><li><p>对于 parentGroup 来说，NioEventLoop <u>创建&#x2F;启动工作线程</u> 的时机是在服务端 ServerBootstrap 启动时，向 parentGroup 注册 NioServerSocketChannel 的时候，详阅: <a href="/posts/44903.html" title="Netty_ServerBootstrap启动过程">Netty_ServerBootstrap启动过程</a> 。</p><p></p></li><li><p>对于 childGroup 来说，NioEventLoop <u>创建&#x2F;启动工作线程</u> 的时机是在客户端通过与 parentGroup 中 EventLoop(NioServerSocketChannel) 进行交互并建立连接完成后，再通过 ServerBootstrapAcceptor 将客户端连接(socketChannel) 注册到 childGroup 的时候，详阅: <a href="/posts/56717.html" title="Netty_ServerBootstrapAcceptor">Netty_ServerBootstrapAcceptor</a> 。</p><p></p></li></ul><p>此处以 <b><font color="#008B45"><i>服务端 ServerBootstrap 启动时，向 parentGroup 中注册 NioServerSocketChannel</i></font></b> 场景为例，分析 NioEventLoop 启动和运行。</p><p>源码入口位于 <code>AbstractChannel.AbstractUnsafe#register</code> 方法，此方法的部分主要作用是将当前 Unsafe 对应的 Channel 注册到 EventLoop 的 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannel</span> <span class="keyword">extends</span> <span class="title class_">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前线程是否是 NioEventLoop 中的线程</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">            <span class="comment">// 注册</span></span><br><span class="line">            register0(promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 对于 NioEventLoop 启动工作线程来说,重点方法是: eventLoop.execute(...)</span></span><br><span class="line">                eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; register0(promise); &#125; &#125;);</span><br><span class="line">            &#125;...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#008B45">注意：这里不关注 Channel 注册到 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上的逻辑，即不关注 <code>register0(promise)</code> 方法，而<b>重点关注向 NioEventLoop 提交第一个任务触发其工作线程启动，即关注: line:14 -&gt; <code>eventLoop.execute</code> 方法</b> </font>。</p><p><code>eventLoop.execute</code> 是一个重要方法，此方法来自接口 Executor，并在父类 SingleThreadEventExecutor 中被重写，但并<b>没有直接向线程池中提交任务，要注意区分</b>。</p><p>进入 <code>SingleThreadEventExecutor.execute</code> 方法继续往下梳理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SingleThreadEventExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractScheduledEventExecutor</span> <span class="keyword">implements</span> <span class="title class_">OrderedEventExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        execute0(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">execute0</span><span class="params">(<span class="meta">@Schedule</span> Runnable task)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(task, <span class="string">&quot;task&quot;</span>);</span><br><span class="line">        execute(task, !(task <span class="keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task, <span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前执行线程是否为EventLoop内部的工作线程</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line">        <span class="comment">// 将任务添加到内部队列</span></span><br><span class="line">        addTask(task);</span><br><span class="line">        <span class="comment">// 如果不是 EventLoop 工作线程提交的task，则判断工作线程是否已经启动，没有则启动工作线程</span></span><br><span class="line">        <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">            <span class="comment">// 启动工作线程</span></span><br><span class="line">            startThread();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;</span><br><span class="line">            wakeup(inEventLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">            <span class="comment">// CAS操作，以非阻塞的线程安全方式更新</span></span><br><span class="line">            <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="built_in">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 启动工作线程</span></span><br><span class="line">                    doStartThread();</span><br><span class="line">                    success = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;...&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>line: 9 -&gt; <code>!(task instanceof LazyRunnable) &amp;&amp; wakesUpForTask(task)</code>，判断任务是否要立即执行。<br><code>!(task instanceof LazyRunnable)</code>：只要提交的任务不是 <code>LazyRunnable</code> 类型，返回true，是需要立即执行的。<br><code>wakesUpForTask(task)</code>：固定返回 true。<br>综上，只要提交的任务不是 LazyRunnable 类型，都是需要立即执行的，在 <a href="#%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98">遗留问题(点击跳转)</a> 小节还会有分析。</p><p></p></li><li><p>line: 16 -&gt; 将任务添加到 NioEventLoop 的 <u>taskQueue 普通任务队列</u> 中。</p><p></p></li><li><p>line: 35 -&gt; 准备启动 NioEventLoop 中的工作线程。</p></li></ul><br><p>doStartThread 方法看起来很长，简单来说就是向 NioEventLoop 内部的 ThreadPerTaskExecutor 提交一个线程, 而这个线程就是 NioEventLoop 内部的工作线程。</p><p>注意：<font color="#FF4500">↓↓↓↓↓第6行向线程池中提交的 Runnable，就是 NioEventLoop 中的工作线程。↓↓↓↓↓</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SingleThreadEventExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractScheduledEventExecutor</span> <span class="keyword">implements</span> <span class="title class_">OrderedEventExecutor</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doStartThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> thread == <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 对于 NioEventLoop，这个 executor 就是 ThreadPerTaskExecutor</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">// &lt;- 这个线程就是 NioEventLoop 内部的工作线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 这个线程设置为 NioEventLoop 的工作线程</span></span><br><span class="line">                thread = Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                    thread.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                updateLastExecutionTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 重要! 执行 SingleThreadEventExecutor 的 run() 方法，它在 NioEventLoop 中实现了</span></span><br><span class="line">                    SingleThreadEventExecutor.<span class="built_in">this</span>.run();</span><br><span class="line">                    success = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; ... &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>line: 6 -&gt; executor 是在 <code>MultithreadEventExecutorGroup</code> 中创建的 ThreadPerTaskExecutor , 详阅：<a href="/posts/15160.html" title="Netty_NioEventLoop创建">Netty_NioEventLoop创建</a> 中「创建线程池」一节。</p><p></p></li><li><p>line: 6 -&gt; <font color="#008B45">向 ThreadPerTaskExecutor 中提交的的这个 Runnable 线程，就是 NioEventLoop 内部的工作线程</font>。</p><p></p></li><li><p>line: 8 ~ line: 20 -&gt; NioEventLoop 工作线程中的核心逻辑。</p></li></ul><p><code>SingleThreadEventExecutor.this.run();</code> 方法是 NioEventLoop 工作线程中的核心逻辑，此方法是 SingleThreadEventExecutor 类中的抽象方法，NioEventLoop 中进行了实现，因此实际调用的是 <code>NioEventLoop#run</code> 方法。</p><br><h1 id="NioEventLoop运行">2. NioEventLoop运行</h1><p>通过 <a href="#NioEventLoop%E5%90%AF%E5%8A%A8">NioEventLoop启动(点击跳转)</a> 小节中的分析已经知道 <code>NioEventLoop#run</code> 方法是 NioEventLoop 工作线程的核心逻辑，被包在 Runnable 中，放入 ThreadPerTaskExecutor 线程池运行的，并且这个 Runnable 就是 NioEventLoop 中的工作线程。</p><p>下面看看，这个 <code>NioEventLoop#run</code> 方法中做了些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">selectCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> strategy;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确定 select 处理策略，用于控制 select 循环行为，包含 CONTINUE、SELECT、BUSY_WAIT 三种策略,</span></span><br><span class="line">                    <span class="comment">// Netty不支持 BUSY_WAIT。</span></span><br><span class="line">                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">                    <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                        <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                        <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                            <span class="comment">// 任务队列为空的时候，会执行本逻辑</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 下一次定时任务触发截止时间</span></span><br><span class="line">                            <span class="type">long</span> <span class="variable">curDeadlineNanos</span> <span class="operator">=</span> nextScheduledTaskDeadlineNanos();</span><br><span class="line">                            ...</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!hasTasks()) &#123; <span class="comment">// 再次判断是否有任务</span></span><br><span class="line">                                    strategy = select(curDeadlineNanos); <span class="comment">// 轮询 I/O 事件(轮训就绪的 channel)</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                nextWakeupNanos.lazySet(AWAKE); <span class="comment">// 阻止不必要的唤醒</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// fall through</span></span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行到这里说明满足了唤醒条件，EventLoop 线程从 Selector 上被唤醒开始处理 IO就绪事件 和 执行异步任务。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 轮训次数++，用来解决jdk空轮训bug</span></span><br><span class="line">                selectCnt++;</span><br><span class="line">                <span class="comment">// ioRatio参数用于控制I/O事件处理和内部任务处理的时间比例，</span></span><br><span class="line">                <span class="comment">// 默认为50,一半时间用来处理io事件,一半时间用来处理任务</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">                <span class="type">boolean</span> ranTasks;</span><br><span class="line">                <span class="comment">// 根据 ioRatio，选择 执行IO操作还是内部队列中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            processSelectedKeys(); <span class="comment">// I/O操作，根据 selectedKey 进行出炉</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        ranTasks = runAllTasks(); <span class="comment">// 执行完所有任务</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// I/O操作，根据selectedKey进行出炉</span></span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 按照一定比例执行任务，可能会遗留一部分任务等待下次执行</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                        ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ranTasks = runAllTasks(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ranTasks || strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unexpectedSelectorWakeup(selectCnt)) &#123;</span><br><span class="line">                    <span class="comment">// unexpectedSelectorWakeup 方法用于解决JDK的epoll空轮询问题</span></span><br><span class="line">                    selectCnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123; ... &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个代码有点多，稍微拆解一下：</p><ul><li><p>line: 6 -&gt; 线程中运行的是死循环逻辑, 只要不出现异常就会一直运行下去。</p><p></p></li><li><p>line: 9 ~ line: 33 -&gt; 这块逻辑中主要做一件事： Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 轮询注册其上 Channel 感兴趣的 <u>I&#x2F;O就绪事件</u> &amp; <u>获取轮询策略</u>，下面单独分析。</p><p></p></li><li><p>line: 38 ~ line: 72 -&gt; 这块逻辑中主要做两件事：<u>处理I&#x2F;O就绪事件</u> 和 <u>执行异步任务</u>，下面单独分析。</p></li></ul><br><h2 id="轮询IO就绪事件-轮询策略">2.1. 轮询IO就绪事件&amp;轮询策略</h2><p>如下提取的部分源码中，可以看出 NioEventLoop 内的工作线程主要做了下面两个事情：</p><ul><li>line: 7 -&gt; 结合异步任务队列，计算轮询策略结果。</li><li>line: 22 -&gt; Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 轮询 <u>I&#x2F;O就绪事件</u>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ...</span><br><span class="line">            strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">            <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE: <span class="comment">// -2</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT: <span class="comment">// -3, NioEventLoop不支持, 跳转到 SelectStrategy.SELECT 策略</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT: <span class="comment">// -1, 任务队列为空的时候, 会执行本逻辑</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 下一次定时任务触发截止时间</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">curDeadlineNanos</span> <span class="operator">=</span> nextScheduledTaskDeadlineNanos();</span><br><span class="line">                    <span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        curDeadlineNanos = NONE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!hasTasks()) &#123; <span class="comment">// 再次判断是否有任务</span></span><br><span class="line">                            strategy = select(curDeadlineNanos); <span class="comment">// 轮询 I/O 事件(轮训就绪的 channel)</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        nextWakeupNanos.lazySet(AWAKE); <span class="comment">// 阻止不必要的唤醒</span></span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="获取轮询策略">2.1.1. 获取轮询策略</h3><p>NioEventLoop 内的工作线程最重要的事情之一就是：通过 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 轮询注册其上的 Channel 感兴趣的 <u>I&#x2F;O就绪事件</u>。</p><blockquote><p>对于 NioServerSocketChannel 来说，因为它主要负责接收客户端连接所以监听的是 <code>OP_ACCEPT</code> 事件。<br>对于 NioSocketChannel 来说，因为它主要负责处理连接上的读写事件所以监听的是 <code>OP_READ</code> 和 <code>OP_WRITE</code> 事件。</p></blockquote><p>selectStrategy 则用于控制轮询策略。当存在异步任务时，会优先执行 <u>I&#x2F;O就绪事件</u>，再执行异步任务。<br>selectStrateg 是在 NioEventLoopGroup 的构造函数中创建的，默认实现为 <code>DefaultSelectStrategyFactory.INSTANCE</code>，详阅：<a href="/posts/15160.html" title="Netty_NioEventLoop创建">Netty_NioEventLoop创建</a> 中「NioEventLoopGroup的构造函数」一节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ...</span><br><span class="line">            strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">            <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE: <span class="comment">// -2</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT: <span class="comment">// -3, NioEventLoop不支持, 跳转到 SelectStrategy.SELECT 策略</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT: <span class="comment">// -1, 任务队列为空的时候, 会执行本逻辑</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty 中定义了三种轮询策略(<code>io.netty.channel.SelectStrategy</code>)：</p><ul><li><p><code>SelectStrategy.SELECT</code>(-1)：此时没有任何异步任务需要执行，NioEventLoop 工作线程可以安心的阻塞在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上等待 <u>I&#x2F;O就绪事件</u> 的来临。</p><p></p></li><li><p><code>SelectStrategy.CONTINUE</code>(-2)：重新开启一轮 IO轮询。</p><p></p></li><li><p><code>SelectStrategy.BUSY_WAIT</code>(-3)： NioEventLoop 内的工作线程要进行自旋轮询，由于 NIO 不支持自旋操作，所以会直接跳转到 SelectStrategy.SELECT 策略中。</p><p></p></li></ul><hr><p>在分析 selectStrategy 计算轮询策略之前首先判断当前是否有异步任务需要执行，即：<code>hasTasks()</code> 方法，判断依据就是查看 <u>taskQueue 普通任务队列</u> 和 <u>tailTask 尾部队列</u> 中是否有任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SingleThreadEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventExecutor</span> <span class="keyword">implements</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">hasTasks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.hasTasks() || !tailTasks.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SingleThreadEventExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractScheduledEventExecutor</span> <span class="keyword">implements</span> <span class="title class_">OrderedEventExecutor</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">hasTasks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="title function_">inEventLoop</span><span class="params">()</span>;</span><br><span class="line">        <span class="keyword">return</span> !taskQueue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着根据 <code>hasTasks()</code> 方法结果，计算轮询策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DefaultSelectStrategy</span> <span class="keyword">implements</span> <span class="title class_">SelectStrategy</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="type">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 如果有异步任务等待执行，则马上执行 selectNow() 非阻塞轮询一次IO就绪事件</span></span><br><span class="line">        <span class="comment">// 没有异步任务，则跳转到 switch select 分支</span></span><br><span class="line">        <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>selectNow()</code> 非阻塞方法返回值表示，此时有多少 <u>I&#x2F;O就绪事件</u> 的 Channel；等于零时表示当前没有 <u>I&#x2F;O就绪事件</u> 的 Channel。</p></blockquote><ul><li><p>如果 NioEventLoop 中有异步任务等待执行，<br>那么 NioEventLoop 中的工作线程需要立即去执行异步任务，但在 <code>calculateStrategy</code> 方法返回之前要顺便调用 <code>selectNow()</code> 非阻塞方法，检查当前是否有 <u>I&#x2F;O就绪事件</u> 发生。</p><ul><li>如果当前有 <u>I&#x2F;O就绪事件</u> ，那正好可以与异步任务一起处理， <code>selectNow()</code> 非阻塞方法返回值大于零；</li><li>如果当前没有 <u>I&#x2F;O就绪事件</u> ，那就及时处理 <u>taskQueue 普通任务队列</u> 和 <u>tailTask 尾部队列</u> 中的异步任务， <code>selectNow()</code> 非阻塞方法返回值等于零。</li></ul><p>Netty 要求 NioEventLoop 中的工作线程优先保证 <u>I&#x2F;O就绪事件</u> 的处理，然后再及时处理异步任务。如果当前没有 <u>I&#x2F;O就绪事件</u> 但有异步任务需要执行，那就去执行异步任务，而不是继续阻塞等待 <u>I&#x2F;O就绪事件</u> 。</p><br></li><li><p>如果当前 NioEventLoop 中没有异步任务需要执行<br>那么 <code>calculateStrategy</code> 方法直接返回 <code>SelectStrategy.SELECT</code>，即：-1 。<br>但当 <code>calculateStrategy</code> 方法通过 <code>selectNow()</code> 非阻塞方法返回非零数值时，表示此时有 <u>IO就绪</u> 的 Channel ，<code>selectNow()</code> 非阻塞方法的返回值表示有多少个 <u>IO就绪</u> 的 Channel。</p></li></ul><hr><p>简单小结下轮询策略，即 <code>selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())</code> 方法的返回值含义：</p><ul><li><p>返回值 &#x3D; -1： switch 逻辑分支进入 <code>SelectStrategy.SELECT</code> 分支，表示此时 NioEventLoop 中 <u>taskQueue(普通任务队列)</u> 和 <u>tailTaskQueue(尾部任务队列)</u> 中没有异步任务需要执行，工作线程可以安心的阻塞在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上等待 <u>I&#x2F;O就绪事件</u> 发生。</p><p></p></li><li><p>返回值 &#x3D; 0：switch 逻辑分支进入 <code>default</code> 分支，表示此时没有 <u>I&#x2F;O就绪事件</u> 但是 <u>taskQueue(普通任务队列)</u> 和 <u>tailTaskQueue(尾部任务队列)</u> 中有异步任务需要执行。</p><p></p></li><li><p>返回值 &gt; 0：switch 逻辑分支进入 <code>default</code> 分支，表示此时既有 <u>I&#x2F;O就绪事件</u> ，在 <u>taskQueue(普通任务队列)</u> 和 <u>tailTaskQueue(尾部任务队列)</u> 中也有异步任务需要执行。</p></li></ul><br><h3 id="轮询IO就绪事件">2.1.2. 轮询IO就绪事件</h3><p>上面是 <u>获取轮询策略</u> 的逻辑，下面梳理分析 <u>轮询I&#x2F;O就绪事件</u>，也就是 line: 12 ~ line: 30 -&gt; <code>switch...SelectStrategy.SELECT</code> 分支逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ...</span><br><span class="line">            strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">            <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE: <span class="comment">// -2</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT: <span class="comment">// -3, NioEventLoop不支持, 跳转到 SelectStrategy.SELECT 策略</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT: <span class="comment">// -1, 当前没有异步任务执行，可以放心的阻塞等待IO就绪事件</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从定时任务队列中取出, 即将快要执行的定时任务的 deadlineNanos(下一次定时任务触发截止时间)。</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">curDeadlineNanos</span> <span class="operator">=</span> nextScheduledTaskDeadlineNanos();</span><br><span class="line">                    <span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        <span class="comment">// -1 代表当前定时任务队列中没有定时任务</span></span><br><span class="line">                        curDeadlineNanos = NONE;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 最早执行定时任务的 deadlineNanos(下一次定时任务触发截止时间) 作为 select 的阻塞时间,</span></span><br><span class="line">                    <span class="comment">// 意思是到了定时任务的执行时间, 不管有无 I/O就绪事件, 必须唤醒 selector, 从而使线程执行定时任务</span></span><br><span class="line">                    nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!hasTasks()) &#123; <span class="comment">// 再次判断是否有任务</span></span><br><span class="line">                            strategy = select(curDeadlineNanos); <span class="comment">// 没有任务, select 阻塞轮询 I/O就绪事件</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        nextWakeupNanos.lazySet(AWAKE); <span class="comment">// 阻止不必要的唤醒</span></span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略过一遍上面的代码，发现 NioEventLoop 中还有定时任务相关逻辑，在 <a href="/posts/15160.html" title="Netty_NioEventLoop创建">Netty_NioEventLoop创建</a> 的「创建 NioEventLoop」一节中，曾经提到过。</p><blockquote><p>NioEventLoop 中的异步任务分为三类：</p><ul><li>普通任务：Netty 最主要执行的异步任务，存放于 <u>taskQueue(普通任务队列)</u>。</li><li>定时任务：存放于 <u>scheduledTaskQueue(定时任务队列&#x2F;优先级队列)</u> 中。</li><li>尾部任务：存放于 <u>tailTaskQueue(尾部任务队列)</u> ，尾部任务不常用，定时任务和普通任务执行完后才会执行尾部任</li></ul></blockquote><p>既然 NioEventLoop 需要执行定时任务，那么它就不能一直阻塞在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上等待 <u>I&#x2F;O就绪事件</u>。为了保证 NioEventLoop 的工作线程能及时执行定时任务，因此需要在即将执行第一个定时任务触发截止时间(<code>deadlineNanos</code>)之前将工作线程唤醒。</p><p>所以在 NioEventLoop 工作线程开始轮询 <u>I&#x2F;O就绪事件</u> 之前，首先<b>要计算出工作线程在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上阻塞的时间</b>。</p><p><br><br></p><h4 id="计算阻塞时间">2.1.2.1. 计算阻塞时间</h4><p>从 NioEventLoop 的 <u>scheduledTaskQueue(定时任务队列&#x2F;优先级队列)</u> 中取出即将快要执行的定时任务，定时任务中的 <code>deadlineNanos</code> 属性就是该任务的执行时间。将这个 <code>deadlineNanos</code> 作为工作线程在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上阻塞轮询的超时时间，这样就可以保证在定时任务即将要执行时，工作线程可以及时从 Selector 上被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractScheduledEventExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractEventExecutor</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">nextScheduledTaskDeadlineNanos</span><span class="params">()</span> &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();</span><br><span class="line">        <span class="comment">// -1 代表当前定时任务队列中没有定时任务</span></span><br><span class="line">        <span class="keyword">return</span> scheduledTask != <span class="literal">null</span> ? scheduledTask.deadlineNanos() : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ScheduledFutureTask&lt;?&gt; peekScheduledTask() &#123;</span><br><span class="line">        Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="built_in">this</span>.scheduledTaskQueue;</span><br><span class="line">        <span class="keyword">return</span> scheduledTaskQueue != <span class="literal">null</span> ? scheduledTaskQueue.peek() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nextScheduledTaskDeadlineNanos()</code> 方法会返回 <u>scheduledTaskQueue(定时任务队列&#x2F;优先级队列)</u> 中最近一个定时任务的<code>deadlineNanos</code> 时间点，如果 <u>scheduledTaskQueue(定时任务队列&#x2F;优先级队列)</u> 中没有定时任务，则返回 <code>-1</code>。</p><p>NioEventLoop 中 <code>nextWakeupNanos</code> 属性用来存放内存工作线程从 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上被唤醒的时间点，如果当前 <u>scheduledTaskQueue(定时任务队列&#x2F;优先级队列)</u> 中没有定时任务需要执行(即：<code>-1</code>)，那就设置为 <code>Long.MAX_VALUE</code> 一直阻塞轮询，直到有 <u>I&#x2F;O就绪事件</u> 到达或者 <u>scheduledTaskQueue(定时任务队列&#x2F;优先级队列)</u> 中有异步任务需要执行。</p><p><br><br></p><h4 id="开始轮询">2.1.2.2. 开始轮询</h4><p>上面确定好工作线程在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上阻塞的时间后，NioEventLoop 就开始轮询 <u>I&#x2F;O就绪事件</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> SelectStrategy.SELECT: <span class="comment">// -1, 当前没有异步任务执行，可以放心的阻塞等待IO就绪事件</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">if</span> (!hasTasks()) &#123; <span class="comment">// 再次判断是否有任务</span></span><br><span class="line">                        strategy = select(curDeadlineNanos); <span class="comment">// 没有任务, select 阻塞轮询 I/O就绪事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    nextWakeupNanos.lazySet(AWAKE); <span class="comment">// 阻止不必要的唤醒</span></span><br><span class="line">                &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在工作线程开始阻塞轮询 <u>I&#x2F;O就绪事件</u> 之前还需要再次检查一下 <u>taskQueue(普通任务队列)</u> 和 <u>tailTaskQueue(尾部任务队列)</u> 中是否有异步任务需要执行。</p><p>如果此时恰巧有异步任务提交，就需要停止 <u>I&#x2F;O就绪事件</u> 的轮询，转去执行异步任务。如果没有异步任务，则正式开始轮询 <u>I&#x2F;O就绪事件</u> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">long</span> deadlineNanos)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (deadlineNanos == NONE) &#123;</span><br><span class="line">            <span class="comment">// 调用底层 NIO Selector 的 select 阻塞方法, 返回就绪 IO 事件的个数</span></span><br><span class="line">            <span class="keyword">return</span> selector.select();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 deadlineNanos 小于5纳秒, 则为0,否则取整为1毫秒, 为了向上取整, 转成毫秒</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timeoutMillis</span> <span class="operator">=</span> deadlineToDelayNanos(deadlineNanos + <span class="number">995000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// selector.selectNow() 是立即返回的, 不会阻塞当前线程。</span></span><br><span class="line">        <span class="comment">// 返回 IO就绪 Channel 的数量。</span></span><br><span class="line">        <span class="keyword">return</span> timeoutMillis &lt;= <span class="number">0</span> ? selector.selectNow() : selector.select(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>deadlineNanos == NONE</code>，代表当前 NioEventLoop 的 <u>scheduledTaskQueue(定时任务队列&#x2F;优先级队列)</u> 中没有定时任务，工作线程可以安心的阻塞在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上等待 <u>I&#x2F;O就绪事件</u> 。</p><blockquote><p>需要注意，<code>selector.select()</code> 是一个阻塞方法，如果没有 <u>I&#x2F;O就绪事件</u> 到来，工作线程就会一直阻塞在此，直到 <u>I&#x2F;O就绪事件</u> 到来。那么问题来了，如果此时工作线程正阻塞在 <code>selector.select()</code> 方法上，等待 <u>I&#x2F;O就绪事件</u> 的到来，而此时正好有异步任务被提交到 <u>taskQueue(普通任务队列)</u> 或 <u>tailTaskQueue(尾部任务队列)</u> 中需要执行，并且此时就是没有任何 <u>I&#x2F;O就绪事件</u> ，那工作线程该如何去执行异步任务呢？</p><p>这个问题先 <mark>MARK</mark>，下面单独分析。</p></blockquote><p>如果 <code>deadlineNanos != NONE</code>，表示此时 NioEventLoop 的 <u>scheduledTaskQueue(定时任务队列&#x2F;优先级队列)</u> 中是有定时任务需要执行的，但还没到任务触发截止时间。</p><p><code>deadlineNanos</code> 单位是纳秒，表示绝对时间，所以在工作线程开始阻塞在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上之前，需要计算出 当前时间(<code>current</code>) 至 绝对时间(<code>deadlineNanos</code>) 之间的 时间差(<code>timeoutMillis</code>)，并转换成毫秒。如果 <code>deadlineNanos</code> 小于5纳秒，则为0，否则向上取整为1毫秒，所以在有定时任务的情况下，至少要阻塞1毫秒。</p><p>当 <code>deadlineToDelayNanos</code> 方法计算出的结果 <code>timeoutMillis &lt;= 0</code> 时，表示临近定时任务触发截止时间，需要立即返回不能阻塞在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上。并且在返回前调用 <code>selector.selectNow()</code> 非阻塞方法，轮询一下当前是否有 <u>I&#x2F;O就绪事件</u> 到达，防止耽误 <u>I&#x2F;O就绪事件</u> 的处理。</p><p>当 <code>timeoutMillis &gt; 0</code> 时，工作线程可以安心的阻塞在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上等待 <u>I&#x2F;O就绪事件</u> 到来，直到到达 <code>timeoutMillis</code> 超时时间。当有 <u>I&#x2F;O就绪事件</u> 到达，工作线程就会被唤醒，接着工作线程就可以去处理 <u>I&#x2F;O就绪事件</u> 。</p><p><code>NioEventLoop#select</code> 方法最终返回的是 <u>IO就绪</u> Channel 的数量。</p><p><br><br></p><h4 id="遗留问题">2.1.2.3. 遗留问题</h4><p>上面还遗留了一个问题，当工作线程正阻塞在 <code>selector.select()</code> 方法上，等待 <u>I&#x2F;O就绪事件</u> 的到来，而此时正好有异步任务被提交到 <u>taskQueue(普通任务队列)</u> 或 <u>tailTaskQueue(尾部任务队列)</u> 中需要执行，并且此时就是没有任何 <u>I&#x2F;O就绪事件</u> ，那工作线程该如何去执行异步任务呢？</p><p><font color="#D2691E">如果异步任务在被提交后希望立即得到执行，那就需要<b>「在提交异步任务的时候去唤醒此时正阻塞在 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上的工作线程」</b></font>。</p><p>在 <a href="#NioEventLoop%E5%90%AF%E5%8A%A8">NioEventLoop启动(点击跳转)</a> 小节中梳理过 <code>SingleThreadEventExecutor#execute</code> 方法，例如在服务端 ServerBootstrap 启动阶段，<i>将 NioServerSocketChannel 注册到 NioEventLoop 中的 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上</i> 等重要操作都是封装成异步任务通过此方法提交到 NioEventLoop 中执行的，部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SingleThreadEventExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractScheduledEventExecutor</span> <span class="keyword">implements</span> <span class="title class_">OrderedEventExecutor</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> addTaskWakesUp;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task, <span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前执行线程是否为EventLoop内部的工作线程</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line">        <span class="comment">// 将任务添加到内部队列</span></span><br><span class="line">        addTask(task);</span><br><span class="line">        <span class="comment">// 如果不是 EventLoop 工作线程提交的task，则判断工作线程是否已经启动，没有则启动工作线程</span></span><br><span class="line">        <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">            <span class="comment">// 启动工作线程</span></span><br><span class="line">            startThread();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;</span><br><span class="line">            wakeup(inEventLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在 <code>SingleThreadEventExecutor#execute</code> 方法的后半段，line: 16 ~ line: 18 ，wakeup 逻辑部分。</p><p>先了解下 wakeup 逻辑相关的两个参数：<code>addTaskWakesUp</code> 和 <code>immediate</code>：</p><ul><li><p>immediate：提交的任务是否需要被立即执行。在 Netty 中只要提交的任务不是 <code>LazyRunnable</code> 类型，都是需要立即执行的，即：<code>immediate = true</code>。</p><p></p></li><li><p>addTaskWakesUp：唤醒工作线程的标识。<br>创建 NioEventLoop 时， <code>addTaskWakesUp</code> 被初始化为 false。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addTaskWakesUp – true if and only if invocation of addTask(Runnable) will wake up the executor thread</span><br></pre></td></tr></table></figure><p>根据 SingleThreadEventExecutor 构造函数上注释的理解，如果 <code>addTaskWakesUp</code> 为 true，代表「仅当调用 <code>addTask</code> 方法时才会唤醒 NioEvnetLoop 中的工作线程，调用其他方法不会唤醒 NioEvnetLoop 中的工作线程」。<br>根据这个理解进行反推，如果 <code>addTaskWakesUp</code> 为 false，代表「并不是只有调用 <code>addTask</code> 方法才能唤醒 NioEventLoop 中的工作线程，调用其他方法也可以唤醒 NioEventLoop 中的工作线程」。</p><blockquote><p>需要注意的是，在 SingleThreadEventExecutor 类中除了 execute(java.lang.Runnable, boolean) 方法，还有 shutdownGracefully 方法和 shutdown 方法都用到了 <code>addTaskWakesUp</code> 参数进行判断，是否要唤醒 NioEventLoop 中的工作线程。</p></blockquote><p></p></li></ul><p>以上，只要当前使用的是 NioEventLoop，并且提交的任务不是 <code>LazyRunnable</code> 类型，都会进入 wakeup 逻辑部分，即：提交的任务会立即执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">AWAKE</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextWakeupNanos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(AWAKE);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">boolean</span> inEventLoop)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) != AWAKE) &#123;</span><br><span class="line">            <span class="comment">// 将 NioEventLoop 内的工作线程 从 Selector 上唤醒。</span></span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>nextWakeupNanos.getAndSet(AWAKE) == AWAKE</code>，表示当前 NioEventLoop 内的工作线程正处于苏醒状态，因此没有必要去执行 <code>selector.wakeup()</code> 而重复唤醒工作线程，这样能节省一次系统调用开销。</p><br><h2 id="IO事件与任务的处理分配">2.2. IO事件与任务的处理分配</h2><p><u>I&#x2F;O就绪事件</u> 无论什么时候到达，NioEventLoop 内的工作线程都需要保证 <u>I&#x2F;O就绪事件</u> 被及时且完整的处理。为了避免工作线程因处理异步任务时间过长而导致 <u>I&#x2F;O就绪事件</u> 不能被及时处理，使用 <code>ioRatio</code> 参数对执行异步任务进行限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            ...</span><br><span class="line">            strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// I/O操作, 根据 selectedKey 进行出炉</span></span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行完所有任务</span></span><br><span class="line">                    ranTasks = runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// I/O操作, 根据 selectedKey 进行出炉</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 按照一定比例执行任务, 可能会遗留一部分任务等待下次执行</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                    ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 0表示运行运行最小数量的任务, 即63个</span></span><br><span class="line">                ranTasks = runAllTasks(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>line: 8 -&gt; <code>strategy</code> 表示当前 <u>IO就绪</u> Channel 的个数，详阅：<a href="#%E5%BC%80%E5%A7%8B%E8%BD%AE%E8%AF%A2">开始轮询(点击跳转)</a> 小节。</p><p></p></li><li><p>line: 10 -&gt; <code>ioRatio</code> 可以通过 <code>NioEventLoop#setIoRatio</code> 方法进行设置。</p><p></p></li><li><p>line: 11 -&gt; <code>ioRatio == 100</code> ：表示无需考虑异步任务执行时间的限制。<br>当有 <u>I&#x2F;O就绪事件</u> 时(即：<code>strategy &gt; 0</code>)，NioEventLoop 中的工作线程需要优先处理 <u>I&#x2F;O就绪事件</u> ，处理完 <u>I&#x2F;O就绪事件</u> 后执行所有的异步任务(普通任务、尾部任务、定时任务)。</p></li></ul><p></p><ul><li><p>line: 21 -&gt; <code>strategy &gt; 0</code> ，同时 <code>ioRatio</code> 设置的值是默认的 50。<br>先执行 <u>I&#x2F;O就绪事件</u> ，最后统计出执行 <u>I&#x2F;O就绪事件</u> 的耗时(ioTime)，接着根据 <code>ioTime * (100 - ioRatio) / ioRatio</code> 计算出，后面用于执行异步任务的剩余时间。<br>也就是说，NioEventLoop 的工作线程需要在剩余时间内执行有限的异步任务，防止 NioEventLoop 的工作线程处理异步任务时间过长而导致 <u>I&#x2F;O就绪事件</u> 得不到及时处理。</p><blockquote><p>执行 <u>I&#x2F;O就绪事件</u> 和执行异步任务的用时比例是一比一，<code>ioRatio</code> 设置的越高，NioEventLoop 的工作线程执行异步任务的时间占比越小。</p></blockquote><p></p></li><li><p>line: 31 -&gt; 没有 <u>I&#x2F;O就绪事件</u> 需要处理<br>Netty 允许 NioEventLoop 工作线程最多执行 64 个异步任务，然后结束，继续轮训 <u>I&#x2F;O就绪事件</u>。<br>核心目的还是防止 NioEventLoop 工作线程处理异步任务时间过长，导致 <u>I&#x2F;O就绪事件</u> 得不到及时处理。</p><p></p></li></ul><br><p></p><h2 id="处理I-O就绪事件">2.3. 处理I&#x2F;O就绪事件</h2><p>轮询 Select 后，NioEventLoop 已经获取到准备就绪的 I&#x2F;O 事件，接下来需要调用 <code>processSelectedKeys()</code> 方法处理IO事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedKeys != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Netty优化过的 selectedKeys</span></span><br><span class="line">            processSelectedKeysOptimized();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 普通处理逻辑</span></span><br><span class="line">            processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="/posts/15160.html" title="Netty_NioEventLoop创建">Netty_NioEventLoop创建</a> 中「优化NIO原生Selector」一节中曾经提到，出于性能考虑将 selectedKeys 集合的类型由原来的 <code>java.util.HashSet</code> ，替换成 Netty 自己用数组实现的 <code>SelectedSelectionKeySet</code>；通过 DISABLE_KEY_SET_OPTIMIZATION 开关控制是否优化，默认是需要优化的。</p><p>优化开关开启的情况下，Netty 将创建的 SelectedSelectionKeySet 集合保存在 <code>NioEventLoop#selectedKeys</code> 属性中，方便 NioEventLoop 工作线程直接从这里获取 <u>I&#x2F;O就绪事件</u> 的 SelectionKey。</p><p>优化开关关闭的情况下，Netty 会直接采用默认实现，此时 <code>NioEventLoop#selectedKeys</code> 属性为 NULL。</p><ul><li><p>line: 6 -&gt; processSelectedKeysOptimized 方法中处理的是 Netty 优化过的类型 <code>SelectedSelectionKeySet</code>；</p><p></p></li><li><p>line: 9 -&gt; processSelectedKeysPlain 中处理的是默认实现。</p></li></ul><p><br><br></p><h3 id="处理未优化selectedKeys">2.3.1. 处理未优化selectedKeys</h3><p>当注册在 <code>java.nio.channels.Selector</code><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上的 Channel 发生 <u>I&#x2F;O就绪事件</u> 时，<code>java.nio.channels.Selector</code> 会将 <u>I&#x2F;O就绪事件</u> 的 SelectionKey 保存到 <code>sun.nio.ch.SelectorImpl#selectedKeys</code> 集合中。接着 NioEventLoop 工作线程会从 <code>java.nio.channels.Selector#select(long)</code> 阻塞调用中返回。</p><p>因此在调用 processSelectedKeysPlain 方法前先要通过 <code>java.nio.channels.Selector#selectedKeys</code> 方法获取 <u>I&#x2F;O就绪事件</u> 的 SelectionKey 集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeysPlain</span><span class="params">(Set&lt;SelectionKey&gt; selectedKeys)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环所有的 selectedKeys</span></span><br><span class="line">    Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">k</span> <span class="operator">=</span> i.next();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> k.attachment();</span><br><span class="line">        <span class="comment">// 移除处理完的SelectionKey，防止重复处理</span></span><br><span class="line">        i.remove();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            <span class="comment">// I/O 事件由 Netty 负责处理</span></span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用户自定义任务,一般情况下不会执行</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!i.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Netty 在处理I/O事件时，如果发现channel数量超过256个，会将 Channel 从 Selector 对象中移除，</span></span><br><span class="line">        <span class="comment">// 然后将 needsToSelectAgain 置 true，重新做一次轮询，从而确保 keySet 的有效性.</span></span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">            selectAgain();</span><br><span class="line">            selectedKeys = selector.selectedKeys();</span><br><span class="line">            <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = selectedKeys.iterator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>line: 3 -&gt; <code>selectedKeys</code> 集合中存放的全部是 <u>I&#x2F;O就绪事件</u> 的 <code>java.nio.channels.SelectionKey</code>，</p><br></li><li><p>line: 9 ~ line: 10 -&gt; 通过获取 <code>HashSet</code> 的迭代器，逐个处理 <u>I&#x2F;O就绪事件</u> 的 Channel。</p><br></li><li><p>line: 12 -&gt; <code>final Object a = k.attachment();</code> 中存放的是什么？<br>在 <a href="/posts/44903.html" title="Netty_ServerBootstrap启动过程">Netty_ServerBootstrap启动过程</a> 中「doRegister」一节中梳理过，通过调用 JDK 底层 NIO API <code>java.nio.channels.SelectableChannel#register</code>，将 NioServerSocketChannel 中包装的 <u>JDK NIO 原生 ServerSocketChannel</u> 注册到 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上。以此为例，在调用 register 方法时，通过 this 指针将 NioServerSocketChannel 自己作为 SelectionKey 的 attachment 属性注册到 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 中。「这一步完成了 Netty 自定义 Channel 和 <u>JDK NIO 原生 Channel</u> 的绑定」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.nio.AbstractNioChannel#doRegister</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 表示注册操作是否成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于客户端连接事件(OP_ACCEPT)活跃时，attachment 属性类型是 NioServerSocketChannel；<br>对于客户端读写事件(OP_READ、OP_WRITE)活跃时，attachment 属性类型是 NioSocketChannel；</p></blockquote><br></li><li><p>line : 14 -&gt; <code>i.remove();</code> 为什么要删除？<br>通过 <code>k.attachment()</code> 获取到 Netty 自定义 Channel 后，需要将当前的 SelectionKey 删除，<b>「因为 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 自己并不会主动删除已经处理完的 SelectionKey」</b>。<br>这样当这个 Channel 下次再有 <u>I&#x2F;O就绪事件</u> 时，Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 会再次将这个 Channel 对应的 SelectionKey 放入集合中。</p><br></li><li><p>line: 16 ~ line : 24 -&gt; AbstractNioChannel 和 NioTask<br>一种是熟悉的 AbstractNioChannel，不论是服务端使用的 NioServerSocketChannel 还是客户端使用的 NioSocketChannel 都继承自 AbstractNioChannel。<br>另一种是 NioTask，这种类型是 Netty 提供给用的，用户可以自定义逻辑，当 Channel 上发生 <u>I&#x2F;O就绪事件</u> 时执行。<br>重点关注 AbstractNioChannel 类型的处理逻辑即可。</p><br></li><li><p>line: 18 -&gt; processSelectedKey</p><p>首先拿到了 Channel 对应的 unsafe，这是 Netty 中专门用于处理 Channel 底层操作的组件。然后根据收到的事件类型对 Channel 进行不同的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 channel 的内部辅助类 Unsafe，通过 Unsafe 进行IO事件处理</span></span><br><span class="line">        <span class="keyword">final</span> AbstractNioChannel.<span class="type">NioUnsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> ch.unsafe();</span><br><span class="line">        <span class="keyword">if</span> (!k.isValid()) &#123; <span class="comment">// 检查 Key 是否合法 (检查连接是否有效)</span></span><br><span class="line">            <span class="comment">// ... 已失效则关闭对应 Channel</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取IO就绪事件</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">readyOps</span> <span class="operator">=</span> k.readyOps();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理 OP_CONNECT 事件</span></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将该事件从事件集合中清除，避免事件集合中一直存在连接建立事件</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">ops</span> <span class="operator">=</span> k.interestOps();</span><br><span class="line">                ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">                <span class="comment">//触发 channelActive事件 处理 Connect事件</span></span><br><span class="line">                unsafe.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理 WRITE事件 (优先处理,以释放内存)</span></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                ch.unsafe().forceFlush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理 Read事件 或者 Accept事件</span></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                unsafe.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 parentGroup 来说，轮询到的都是 OP_ACCEPT 事件；对于 childGroup 来说，轮询到的都是 I&#x2F;O 读写事件。</p><blockquote><p><b>OP_CONNECT</b></p><p>EventLoop 内部调用了 <code>unsafe.finishConnect()</code>，底层调用<code>pipeline().fireChannelActive()</code> 方法，这时会产生一个 Inbound 事件，在Pipeline中传播，依次调用 ChannelHandler 的 channelActive() 方法，通知各个 ChannelHandler 连接建立成功；</p><hr><p><b>OP_WRITE</b></p><p>内部会执行 <code>ch.unsafe().forceFlush()</code> 操作，将数据刷到对端，最终会调用Java NIO中 <code>Channel .write()</code> 方法执行底层写操作；</p><hr><p><b>OP_READ</b></p><p>Netty 将 OP_READ 和 OP_ACCEPT 事件进行了统一封装，都通过 <code>unsafe.read()</code> 进行处理。</p><ul><li>NioServerSocketChannel ，<code>unsafe.read()</code> 由子类 <code>AbstractNioMessageChannel.NioMessageUnsafe#read</code> 实现。</li><li>NioSocketChannel ，<code>unsafe.read()</code> 由子类 <code>AbstractNioByteChannel.NioByteUnsafe#read</code> 实现。</li></ul></blockquote></li></ul><p><br><br></p><h3 id="处理优化的selectedKeys">2.3.2. 处理优化的selectedKeys</h3><p>再看下 Netty 优化过 selectedKeys 是如何处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeysOptimized</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 SelectionKey</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">k</span> <span class="operator">=</span> selectedKeys.keys[i];</span><br><span class="line">            <span class="comment">// 快速释放,便于GC</span></span><br><span class="line">            selectedKeys.keys[i] = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 从 attachment 获得 netty 的自定义 Channel</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> k.attachment();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理 Channel,IO事件</span></span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">                processSelectedKey(k, task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否该再来次轮询</span></span><br><span class="line">            <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">                selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line">                selectAgain();</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>processSelectedKey 方法在 <a href="#%E5%A4%84%E7%90%86%E6%9C%AA%E4%BC%98%E5%8C%96selectedKeys">处理未优化selectedKeys</a> 小节中分析过，此处不再赘述。</p></blockquote><p><code>processSelectedKeysOptimized</code> 方法与 <code>processSelectedKeysPlain</code> 方法最主要的区别是遍历方式不同，这是因为集合类型不同导致的。</p><p><br><br></p><h3 id="关于selectedKeys的优化">2.3.3. 关于selectedKeys的优化</h3><p>Netty 在创建 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 时会用自定义的 SelectedSelectionKeySet 类型替换 Selector 原本内部的 selectedKeys 和 publicSelectedKeys，从 <code>sun.nio.ch.SelectorImpl</code> 中可以看到这两个属性原本的类型其实是 <code>java.util.HashSet</code>。</p><p>详阅：<a href="/posts/15160.html" title="Netty_NioEventLoop创建">Netty_NioEventLoop创建</a> 中「优化NIO原生Selector」一节。</p><p><br><br></p><h3 id="关于无效key的优化">2.3.4. 关于无效key的优化</h3><p><code>processSelectedKey</code> 方法运行完成， 处理 Channel 的IO事件也就处理完了，但 Netty 还在此基础上做了优化，做了什么优化呢？</p><p>就是在 Netty 拿到一批 key 在进行处理的周期内，如果用户同时也在进行 Channel 的移除操作，这就意味着 Netty 拿到的这一批 key 里面，有些可能已经被用户丢掉了。</p><p>Netty 去处理这些无效的 key 会浪费很多资源。所以 Netty 会在用户移除一定数量的 Channel 之后，丢掉原有的 key，重新 select() 一批出来，以保证 key 的有效性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeysOptimized</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 判断是否该再来次轮询</span></span><br><span class="line">            <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">                <span class="comment">// 清理未处理的 key</span></span><br><span class="line">                selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 重新轮询</span></span><br><span class="line">                selectAgain();</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除 key 的逻辑很简单，就是把数组清空，而重新轮询就是调用一次 selectNow。</p><br><h2 id="执行异步任务">2.4. 执行异步任务</h2><p>接下来 NioEventLoop 就要执行异步任务，上面IO事件处理完成后，即 <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code> 方法运行完成后，最终都会处理 taskQueue 中的异步任务。</p><p>在 <code>NioEventLoop#run</code> 方法中关于异步任务的处理有两个：</p><ul><li><p><code>runAllTasks()</code> 方法，无超时时间限制。当 <code>ioRatio</code> 设置为 100 时，NioEventLoop 的工作线程会先执行 <u>I&#x2F;O就绪事件</u> ，然后再执行所有的异步任务，没有时间限制。</p></li><li><p><code>runAllTasks(long timeoutNanos)</code> 方法，有超时时间限制。当 <code>ioRatio != 100</code> 时，NioEventLoop 的工作线程执行异步时间会有时间限制，在限定时间范围内，执行有限的异步任务。</p><p></p></li></ul><p>这两个处理方法的核心逻辑可以概括为三步：</p><ol><li>合并 <u>taskQueue(普通任务队列)</u> 和 <u>scheduledTaskQueue(定时任务队列&#x2F;优先级队列)</u>。</li><li>统一从 <u>taskQueue(普通任务队列)</u> 中取出任务并执行</li><li>执行 <u>tailTaskQueue(尾部任务队列)</u> 中的任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SingleThreadEventExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractScheduledEventExecutor</span> <span class="keyword">implements</span> <span class="title class_">OrderedEventExecutor</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">runAllTasks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="title function_">inEventLoop</span><span class="params">()</span>;</span><br><span class="line">        <span class="type">boolean</span> fetchedAll;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ranAtLeastOne</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//将到达执行时间的定时任务转存到普通任务队列taskQueue中，统一由工作线程从taskQueue中取出执行</span></span><br><span class="line">            fetchedAll = fetchFromScheduledTaskQueue();</span><br><span class="line">            <span class="keyword">if</span> (runAllTasksFrom(taskQueue)) &#123;</span><br><span class="line">                ranAtLeastOne = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!fetchedAll); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ranAtLeastOne) &#123;</span><br><span class="line">            lastExecutionTime = getCurrentTimeNanos();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行尾部任务队列</span></span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">return</span> ranAtLeastOne;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SingleThreadEventExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractScheduledEventExecutor</span> <span class="keyword">implements</span> <span class="title class_">OrderedEventExecutor</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">runAllTasks</span><span class="params">(<span class="type">long</span> timeoutNanos)</span> &#123;</span><br><span class="line">        <span class="comment">// 将 定时任务 合并到 普通任务队列中</span></span><br><span class="line">        fetchFromScheduledTaskQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理任务</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">            afterRunningAllTasks();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 runAllTasks 的超时时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timeoutNanos &gt; <span class="number">0</span> ? getCurrentTimeNanos() + timeoutNanos : <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">runTasks</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> lastExecutionTime;</span><br><span class="line">        <span class="comment">// 死循环执行</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            safeExecute(task);</span><br><span class="line">            runTasks ++;</span><br><span class="line">            <span class="comment">// 每执行64个任务就检查下是否超时,超时后不再继续执行</span></span><br><span class="line">            <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                lastExecutionTime = getCurrentTimeNanos();</span><br><span class="line">                <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从普通任务队列中取出下一个任务</span></span><br><span class="line">            task = pollTask();</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">                lastExecutionTime = getCurrentTimeNanos();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="built_in">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="合并">2.4.1. 合并</h3><p>合并定时任务到普通任务队列，这一步是调用了 <code>fetchFromScheduledTaskQueue()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">fetchFromScheduledTaskQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduledTaskQueue == <span class="literal">null</span> || scheduledTaskQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nanoTime</span> <span class="operator">=</span> getCurrentTimeNanos();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 从 定时任务队列 中取出执行时间小于等于当前时间的任务</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">scheduledTask</span> <span class="operator">=</span> pollScheduledTask(nanoTime);</span><br><span class="line">        <span class="keyword">if</span> (scheduledTask == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!taskQueue.offer(scheduledTask)) &#123;</span><br><span class="line">            <span class="comment">// 任务队列中没有剩余空间，说明普通任务队列满了添加失败，</span></span><br><span class="line">            <span class="comment">// 把定时任务放回 scheduletaskqueue 以便再次提取它，然后退出</span></span><br><span class="line">            scheduledTaskQueue.add((ScheduledFutureTask&lt;?&gt;) scheduledTask);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Runnable <span class="title function_">pollScheduledTask</span><span class="params">(<span class="type">long</span> nanoTime)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="title function_">inEventLoop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较定时任务的 deadlineNanos 和当前时间，如果小于等于就取出，否则返回 null</span></span><br><span class="line">    ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();</span><br><span class="line">    <span class="keyword">if</span> (scheduledTask == <span class="literal">null</span> || scheduledTask.deadlineNanos() - nanoTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    scheduledTaskQueue.remove();</span><br><span class="line">    scheduledTask.setConsumed();</span><br><span class="line">    <span class="keyword">return</span> scheduledTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到每次取出时会比较定时任务的 deadlineNanos 和当前时间，如果小于等于就取出，否则返回 null。</p><p>由于定时任务是按执行时间排列的优先级队列，所以每次取出都是当前队列中执行时间最小的任务，如果某次取出的任务的执行时间大于当前时间，则说明队列中剩下的任务的执行时间都大于当前时间，合并操作就可以结束了。</p><br><h2 id="完整流程图">2.5. 完整流程图</h2><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/45721/NioEventLoop的启动和运行.png" alt="NioEventLoop的启动和运行(新标签页中打开可放大图片)" style="zoom:70%"><br><h1 id="小结">3. 小结</h1><ul><li><p>NioEventLoop 是一个基于 JDK NIO 的异步事件循环类，它<strong>负责处理一个 Channel 在它的生命周期内的所有事件</strong>。</p></li><li><p>NioEventLoop 和 Channel 是一对多的关系，<strong>一个 NioEventLoop 对应多个 Channel，通过 I&#x2F;O 多路复用来管理多个 Channel</strong>。</p></li><li><p>NioEventLoop <strong>任务队列是一个多生产者单消费者的队列</strong>，所有提交到 NioEventLoop 任务队列中的<strong>任务会被以 FIFO 的方式消费</strong>。</p></li><li><p>NioEventLoop 的整个生命周期只会<strong>依赖于一个单一的线程</strong>来完成。</p></li><li><p>NioEventLoop 内部是一个 for 循环，不间断执行以下三件事情：</p><ul><li><p>select：轮询 Selector 选择器中已经注册的所有 Channel 的 I&#x2F;O 事件；</p></li><li><p>processSelectedKeys：根据 SelectedKeys，处理已经准备就绪的 I&#x2F;O 事件；</p></li><li><p>runAllTasks：执行内部队列中的任务。</p></li></ul></li></ul><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/45721/NioEventLoop_run方法循环执行的三件事.png" alt="NioEventLoop_run方法循环执行的三件事(图片来自网络)" style="zoom:45%"><hr><p>NIO网络编程模型的核心如下图，一个工作线程负责一个Selector，Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 负责轮询其管理的 Channel。</p><p>回过头来看，NioEventLoop 其中封装了下图中的 Thread、Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>、Channel。</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/45721/NIO网络编程模型.png" alt="NIO网络编程模型(图片来自网络)" style="zoom:40%"><hr><p>EventLoop、EventLoopGroup、Channel 之间的关系如下图:</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/45721/EventLoopGroups_EventLoop_Channel关系.png" alt="EventLoopGroups_EventLoop_Channel关系(图片来自网络)" style="zoom:60%"><br><h1 id="Reference">4. Reference</h1><ul><li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483907&idx=1&sn=084c470a8fe6234c2c9461b5f713ff30&chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&scene=21#wechat_redirect">聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)</a></li><li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484087&idx=1&sn=0c065780e0f05c23c8e6465ede86cba0&chksm=ce77c4f0f9004de63be369a664105708bc5975b52993f4a6df223caed34cc1ef6185a16acd75&token=997171731&lang=zh_CN&scene=21#wechat_redirect">一文聊透Netty核心引擎Reactor的运转架构</a></li><li><a target="_blank" rel="noopener" href="https://www.tpvlog.com/article/356#menu_1">透彻理解Java网络编程（十一）——Netty原理：EventLoopGroup和EventLoop</a></li><li><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/04%20%E4%BA%8B%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%B1%82%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%20EventLoop%20%E6%98%AF%20Netty%20%E7%9A%84%E7%B2%BE%E9%AB%93%EF%BC%9F.md">04 事件调度层：为什么 EventLoop 是 Netty 的精髓？</a></li><li><a target="_blank" rel="noopener" href="http://www.linkedkeeper.com/1695.html">Netty 核心源码解读 —— EventLoop 篇</a></li><li><a target="_blank" rel="noopener" href="http://huzb.me/2019/09/27/netty%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94NioEventLoop/">Netty 源码浅析——NioEventLoop</a></li></ul><br><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0;margin-left:40px"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px;margin-left:-40px">1.</span><span style="display:inline-block;vertical-align:top;margin-left:10px">java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div><link rel="stylesheet" href="/css/folder.css" type="text/css"><script src="/js/folder.js" type="text/javascript" async></script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></div><div id="btn-catalog" class="btn-catalog"><i class="iconfont icon-catalog"></i></div><div class="post-catalog hidden" id="catalog"><div class="title">目录</div><div class="catalog-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NioEventLoop%E5%90%AF%E5%8A%A8"><span class="toc-text">1. NioEventLoop启动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NioEventLoop%E8%BF%90%E8%A1%8C"><span class="toc-text">2. NioEventLoop运行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2IO%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6-%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5"><span class="toc-text">2.1. 轮询IO就绪事件&amp;轮询策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5"><span class="toc-text">2.1.1. 获取轮询策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2IO%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.1.2. 轮询IO就绪事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E9%98%BB%E5%A1%9E%E6%97%B6%E9%97%B4"><span class="toc-text">2.1.2.1. 计算阻塞时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E8%BD%AE%E8%AF%A2"><span class="toc-text">2.1.2.2. 开始轮询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98"><span class="toc-text">2.1.2.3. 遗留问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86%E5%88%86%E9%85%8D"><span class="toc-text">2.2. IO事件与任务的处理分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86I-O%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.3. 处理I&#x2F;O就绪事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%AA%E4%BC%98%E5%8C%96selectedKeys"><span class="toc-text">2.3.1. 处理未优化selectedKeys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96%E7%9A%84selectedKeys"><span class="toc-text">2.3.2. 处理优化的selectedKeys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EselectedKeys%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">2.3.3. 关于selectedKeys的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%97%A0%E6%95%88key%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">2.3.4. 关于无效key的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-text">2.4. 执行异步任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6"><span class="toc-text">2.4.1. 合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">2.5. 完整流程图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">3. 小结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-text">4. Reference</span></a></li></ol></div></div><script src="/js/catalog.js"></script><div class="comments-container"></div></div><div class="footer"><div class="social"><ul><li><a title="github" target="_blank" rel="noopener" href="https://github.com/Simba-cheng"><i class="iconfont icon-github"></i></a></li><li><a title="rss" href="/atom.xml"><i class="iconfont icon-rss"></i></a></li></ul></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a></div><div class="footer-views">本站总访问量<span id="busuanzi_value_site_pv"></span>次 本文总阅读量<span id="busuanzi_value_page_pv"></span>次 本站访客数<span id="busuanzi_value_site_uv"></span>人</div></div></div><div class="tools-bar"><div class="back-to-top tools-bar-item hidden"><a href="javascript: void(0)"><i class="iconfont icon-chevronup"></i></a></div><script src="/js/backtotop.js"></script><div class="search-icon tools-bar-item" id="search-icon"><a href="javascript: void(0)"><i class="iconfont icon-search"></i></a></div><div class="search-overlay hidden"><div class="search-content" tabindex="0"><div class="search-title"><span class="search-icon-input"><a href="javascript: void(0)"><i class="iconfont icon-search"></i> </a></span><input type="text" class="search-input" id="search-input" placeholder="搜索..."> <span class="search-close-icon" id="search-close-icon"><a href="javascript: void(0)"><i class="iconfont icon-close"></i></a></span></div><div class="search-result" id="search-result"></div></div></div><script type="text/javascript">var inputArea=document.querySelector("#search-input"),searchOverlayArea=document.querySelector(".search-overlay");function openOrHideSearchContent(){searchOverlayArea.classList.contains("hidden")?(searchOverlayArea.classList.remove("hidden"),document.body.classList.add("hidden")):(searchOverlayArea.classList.add("hidden"),document.body.classList.remove("hidden"))}function blurSearchContent(e){e.target===searchOverlayArea&&openOrHideSearchContent()}inputArea.onclick=function(){getSearchFile(),this.onclick=null},inputArea.onkeydown=function(){if(13==event.keyCode)return!1},document.querySelector("#search-icon").addEventListener("click",openOrHideSearchContent,!1),document.querySelector("#search-close-icon").addEventListener("click",openOrHideSearchContent,!1),searchOverlayArea.addEventListener("click",blurSearchContent,!1);var searchFunc=function(e,t,n){"use strict";var r=document.getElementById(t),a=document.getElementById(n);a.innerHTML="<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>",$.ajax({url:e,dataType:"xml",success:function(e){var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get();a.innerHTML="",r.addEventListener("input",function(){var u='<ul class="search-result-list">',h=this.value.trim().toLowerCase().split(/[\s\-]+/);if(a.innerHTML="",!(this.value.trim().length<=0)){if(t.forEach(function(e){var n,r,a=!0,t=(e.title&&""!==e.title.trim()||(e.title="Untitled"),e.title.trim()),c=t.toLowerCase(),s=e.content.trim().replace(/<[^>]+>/g,""),i=s.toLowerCase(),e=e.url,l=-1,o=-1;""!==i?h.forEach(function(e,t){n=c.indexOf(e),l=i.indexOf(e),n<0&&l<0?a=!1:(l<0&&(l=0),0==t&&(o=l))}):a=!1,a&&(u+="<li><a href='"+e+"' class='search-result-title'>"+t+"</a>",0<=o&&(e=o+80,(e=0==(t=(t=o-20)<0?0:t)?100:e)>s.length&&(e=s.length),r=s.substr(t,e),h.forEach(function(e){var t=new RegExp(e,"gi");r=r.replace(t,'<span class="search-keyword">'+e+"</span>")}),u+='<p class="search-result-abstract">'+r+"...</p>"),u+="</li>")}),-1===(u+="</ul>").indexOf("<li>"))return a.innerHTML="<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";a.innerHTML=u}})},error:function(e,t,n){a.innerHTML="",404===e.status?a.innerHTML="<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>":a.innerHTML="<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>"}}),$(document).on("click","#search-close-icon",function(){$("#search-input").val(""),$("#search-result").html("")})},getSearchFile=function(){searchFunc("/search.xml","search-input","search-result")}</script><div class="tools-bar-item theme-icon" id="switch-color-scheme"><a href="javascript: void(0)"><i id="theme-icon" class="iconfont icon-moon"></i></a></div><script src="/js/colorscheme.js"></script><div class="share-icon tools-bar-item"><a href="javascript: void(0)" id="share-icon"><i class="iconfont iconshare"></i></a><div class="share-content hidden"><a class="share-item" href="https://twitter.com/intent/tweet?text=' + Netty_NioEventLoop%E5%90%AF%E5%8A%A8%E5%92%8C%E8%BF%90%E8%A1%8C + '&url=' + https%3A%2F%2Fsimba-cheng.github.io%2Fposts%2F45721.html + '" target="_blank" title="Twitter"><i class="iconfont icon-twitter"></i> </a><a class="share-item" href="https://www.facebook.com/sharer.php?u=https://simba-cheng.github.io/posts/45721.html" target="_blank" title="Facebook"><i class="iconfont icon-facebooksquare"></i></a></div></div><script src="/js/shares.js"></script></div></div><script src="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/js/index.js"></script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a=c[o],i=function(){c=c.filter(function(t){return a!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(a)};(t=a).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,n=t.getAttribute("data-original"),e.onload=function(){t.src=n,t.removeAttribute("data-original"),i()},t.src!==n&&(e.src=n))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this)</script><script src="/js/markmap.js"></script></body></html>
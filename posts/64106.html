<!DOCTYPE html><html lang="zh-CN" color-mode="light"><head><link href="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/css/index.css" rel="stylesheet"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><script defer src="/_vercel/insights/script.js"></script><script defer src="/_vercel/speed-insights/script.js"></script><meta name="author" content="yxcheng"><title>🔖 TypeScript-Cheat-Sheet | 躺着好舒服</title><link rel="apple-touch-icon" href="/images/favicon.png"><link rel="icon" href="/images/favicon.png"><link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css"><link rel="stylesheet" href="/css/figcaption/mac-block.css"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3163875893588085" crossorigin="anonymous"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><link href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" rel="stylesheet"><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/fancybox.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-WB9L6JQGS1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-WB9L6JQGS1")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var html=document.documentElement;const colorMode=localStorage.getItem("color-mode");colorMode&&document.documentElement.setAttribute("color-mode",colorMode)</script><link rel="stylesheet" href="/css/collapse-code.css"><script src="/js/collapse-code.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="躺着好舒服" type="application/atom+xml"></head><body><div id="app"><div class="header"><div class="avatar"><a href="/"><img no-lazy src="/images/avatar.png" alt=""></a><div class="nickname"><a href="/">躺着好舒服</a></div></div><div class="navbar"><ul><li class="nav-item" data-path="/"><a href="/">首页</a></li><li class="nav-item" data-path="/tags/"><a href="/tags/">标签</a></li><li class="nav-item" data-path="/categories/"><a href="/categories/">分类</a></li><li class="nav-item" data-path="/archives/"><a href="/archives/">归档</a></li><li class="nav-item" data-path="/notes/"><a href="/notes/">Notes</a></li><li class="nav-item" data-path="/adventure/"><a href="/adventure/">冒险乐园</a></li></ul></div></div><script src="/js/activeNav.js"></script><div class="flex-container"><script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.10/dist/clipboard.min.js"></script><script src="/js/codeCopy.js"></script><div class="container post-details" id="post-details"><div class="post-content"><div class="post-title">🔖 TypeScript-Cheat-Sheet</div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime mr-10" title="更新时间"></i> 创建时间:2025-04-28 14:39:10&nbsp; 更新时间:2025-06-17 13:28:49 &nbsp;&nbsp; </span><span><span><i class="iconfont icon-edit"></i> 10.3k 字 </span>&nbsp;&nbsp; </span><span class="post-tags"><i class="iconfont icon-tags mr-10" title="标签"></i> <span class="span--tag mr-8"><a href="/tags/TypeScript/" title="TypeScript">#TypeScript&nbsp; </a></span><span class="span--tag mr-8"><a href="/tags/%F0%9F%94%96-Cheat-Sheet/" title="🔖 Cheat Sheet">#🔖 Cheat Sheet&nbsp;</a></span></span></div><div class="markdown-body"><center><a style="font-style:italic" href="javascript:window.location='https://simba--cheng-cn.translate.goog/' + window.location.pathname + '?_x_tr_sl=zh-CN&amp;_x_tr_tl=en&amp;_x_tr_hl=zh-CN&amp;_x_tr_pto=wapp';">This post is also available in English and alternative languages.</a></center><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br><h1 id="Cheat-Sheet">1. Cheat Sheet</h1><p>👇👇需要科学上网👇👇</p><iframe width="100%" scrolling="auto" height="500" frameborder="0" src="https://reference-henna.vercel.app/docs/typescript.html"></iframe><p>👉👉👉 <a target="_blank" rel="noopener" href="https://reference-henna.vercel.app/docs/typescript.html">点击跳转 - 需要科学上网</a></p><br><h1 id="封装、抽象、继承和多态">2. 封装、抽象、继承和多态</h1><blockquote style="border-left:4px solid #6495ed;background-color:#f5f5f5;padding:25px 20px 10px;position:relative;margin-top:20px"><div style="position:absolute;top:-15px;left:-10px;background-color:#6495ed;color:#fff;padding:5px 10px;border-radius:3px;font-size:.8em;font-weight:700;box-shadow:0 2px 5px rgba(0,0,0,.1)">引用 & 扩展</div>&#42; <a href="https://dev.to/rajrathod/mastering-object-oriented-programming-with-typescript-encapsulation-abstraction-inheritance-and-polymorphism-explained-c6p" target="_blank">Mastering Object-Oriented Programming with TypeScript: Encapsulation, Abstraction, Inheritance, and Polymorphism Explained</a><br></blockquote><p>面向对象编程（ OOP ）是一种强大的编程范式，广泛应用于软件开发。 TypeScript 作为 JavaScript 的超集，提供了强大的类型系统和面向对象特性，使其成为实现 OOP 原则的理想选择。本文将深入探讨 OOP 的四大核心概念：封装（ Encapsulation ）、抽象（ Abstraction ）、继承（ Inheritance ）和多态（ Polymorphism ），并通过 TypeScript 代码示例加以说明。</p><br><h2 id="封装">2.1. 封装</h2><p>封装是将数据（属性）和操作数据的方法（函数）捆绑在一起，并通过访问控制限制对数据的直接访问。这可以保护数据的完整性，防止外部代码意外修改对象的内部状态。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">accountNumber</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">balance</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">accountNumber: <span class="built_in">string</span>, initialBalance: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">accountNumber</span> = accountNumber;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">balance</span> = initialBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getAccountNumber</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">accountNumber</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getBalance</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">balance</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">deposit</span>(<span class="attr">amount</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">balance</span> += amount;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Deposited <span class="subst">$&#123;amount&#125;</span>. New balance: <span class="subst">$&#123;<span class="variable language_">this</span>.balance&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">withdraw</span>(<span class="attr">amount</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">balance</span> &gt;= amount) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">balance</span> -= amount;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Withdrawn <span class="subst">$&#123;amount&#125;</span>. New balance: <span class="subst">$&#123;<span class="variable language_">this</span>.balance&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Insufficient balance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> account = <span class="keyword">new</span> <span class="title class_">BankAccount</span>(<span class="string">&quot;123456789&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Account Number:&quot;</span>, account.<span class="title function_">getAccountNumber</span>()); <span class="comment">// Output: &quot;Account Number: 123456789&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Balance:&quot;</span>, account.<span class="title function_">getBalance</span>()); <span class="comment">// Output: &quot;Balance: 1000&quot;</span></span><br><span class="line"></span><br><span class="line">account.<span class="title function_">deposit</span>(<span class="number">500</span>); <span class="comment">// Output: &quot;Deposited 500. New balance: 1500&quot;</span></span><br><span class="line">account.<span class="title function_">withdraw</span>(<span class="number">200</span>); <span class="comment">// Output: &quot;Withdrawn 200. New balance: 1300&quot;</span></span><br><span class="line">account.<span class="title function_">withdraw</span>(<span class="number">1500</span>); <span class="comment">// Output: &quot;Insufficient balance&quot;</span></span><br></pre></td></tr></table></figure><p>在此示例中，有一个<code>BankAccount</code>类，它表示一个简单的银行账户。</p><ul><li><p>该类有两个私有属性：<code>accountNumber</code>和<code>balance</code>。这些属性被标记为私有，因此无法从类外部访问它们。这可确保代码的其他部分无法直接访问或修改这些属性。</p></li><li><p><code>deposit</code>和<code>getBalance</code>是公共方法，分别用于修改和获取余额，确保对<code>balance</code>的访问是受控的。</p></li><li><p>直接访问 account.balance 会导致编译错误，体现了封装的保护作用。</p></li></ul><br><h2 id="抽象">2.2. 抽象</h2><p>抽象是指隐藏复杂的实现细节，仅向用户暴露必要的接口或功能。这可以通过<code>TypeScript</code>的抽象类（<code>abstract class</code>）或接口（<code>interface</code>）实现。抽象类可以包含抽象方法（没有实现的方法）和具体方法，而接口通常仅定义方法签名。</p><p>抽象类不能直接实例化，子类必须实现所有抽象方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Abstract class representing a shape</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">getArea</span>(): <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">getPerimeter</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete subclass representing a Circle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getArea</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getPerimeter</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete subclass representing a Rectangle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">width: <span class="built_in">number</span>, height: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getArea</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getPerimeter</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (<span class="variable language_">this</span>.<span class="property">width</span> + <span class="variable language_">this</span>.<span class="property">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printShapeDetails</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Area:&quot;</span>, shape.<span class="title function_">getArea</span>());</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Perimeter:&quot;</span>, shape.<span class="title function_">getPerimeter</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">printShapeDetails</span>(circle);</span><br><span class="line"><span class="comment">// Output: &quot;Area: 78.53981633974483&quot;</span></span><br><span class="line"><span class="comment">// Output: &quot;Perimeter: 31.41592653589793&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">printShapeDetails</span>(rectangle);</span><br><span class="line"><span class="comment">// Output: &quot;Area: 24&quot;</span></span><br><span class="line"><span class="comment">// Output: &quot;Perimeter: 20&quot;</span></span><br></pre></td></tr></table></figure><p><code>Shape</code>是一个抽象类，包含两个抽象方法<code>getArea</code>和<code>getPerimeter</code>。</p><p><code>Circle</code>和<code>Rectangle</code>继承<code>Shape</code>并分别实现了这两个抽象方法。这些子类负责为抽象方法提供具体的实现逻辑。</p><p>通过使用抽象，可以创建一个不同形状的集合，并计算它们的面积和周长，而无需担心每个形状的具体实现细节。</p><p>抽象的便捷之处在于<code>printShapeDetails</code>函数可以处理实现<code>Shape</code>抽象类的任何形状。可以创建新的形状，例如三角形、正方形等，而无需修改<code>Shape</code>类或<code>printShapeDetails</code>函数。这展示了通过抽象实现的灵活性和可重用性。</p><br><h2 id="继承">2.3. 继承</h2><p>继承允许一个类（子类）从另一个类（父类）继承属性和方法，从而实现代码复用和层次结构。 TypeScript 使用 extends 关键字实现继承，子类可以通过 super 关键字调用父类的构造函数或方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base class: Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Some generic sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Name: <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, Age: <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subclass: Dog (inherits from Animal)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, breed: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">super</span>.getInfo()&#125;</span>, Breed: <span class="subst">$&#123;<span class="variable language_">this</span>.breed&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genericAnimal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Generic Animal&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(genericAnimal.<span class="title function_">getInfo</span>()); <span class="comment">// Output: &quot;Name: Generic Animal, Age: 5&quot;</span></span><br><span class="line">genericAnimal.<span class="title function_">makeSound</span>(); <span class="comment">// Output: &quot;Some generic sound&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>, <span class="number">3</span>, <span class="string">&quot;Labrador&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="title function_">getInfo</span>()); <span class="comment">// Output: &quot;Name: Buddy, Age: 3, Breed: Labrador&quot;</span></span><br><span class="line">dog.<span class="title function_">makeSound</span>(); <span class="comment">// Output: &quot;Woof!&quot;</span></span><br></pre></td></tr></table></figure><p>基类<code>Animal</code>，该基类具有<code>name</code>和<code>age</code>属性，以及方法<code>makeSound（）</code>和<code>getInfo（）</code>。然后定义一个继承自<code>Animal</code>的子类<code>Dog</code>。<code>Dog</code>类添加其特定属性<code>breed</code>并覆盖<code>makeSound（）</code>和<code>getInfo（）</code>方法。</p><p>通过使用继承，可以创建一个类的层次结构，其中每个子类都继承并扩展了超类的功能。这种方法允许重用通用代码，定义专用行为，并以结构化和模块化的方式构建复杂的系统。</p><br><h2 id="多态">2.4. 多态</h2><p>多态允许不同类的对象以统一的方式被处理，即使它们的具体实现不同。多态通常通过继承（方法重写）或接口实现。 TypeScript 支持<code>运行时多态（通过继承）</code>和<code>编译时多态（通过接口或类型兼容性）</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译时多态性 Compile-time Polymorphism (Method Overloading)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathOperations</span> &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">a</span>: <span class="built_in">any</span>, <span class="attr">b</span>: <span class="built_in">any</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> math = <span class="keyword">new</span> <span class="title class_">MathOperations</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">10</span>)); <span class="comment">// Output: 15 (number addition)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="string">&quot;Hello, &quot;</span>, <span class="string">&quot;World!&quot;</span>)); <span class="comment">// Output: &quot;Hello, World!&quot; (string concatenation)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时多态性 Run-time Polymorphism (Method Overriding)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Some generic sound&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">animalSound</span>(<span class="params">animal: Animal</span>) &#123;</span><br><span class="line">  animal.<span class="title function_">makeSound</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">animalSound</span>(dog); <span class="comment">// Output: &quot;Woof!&quot; (Dog&#x27;s sound)</span></span><br><span class="line"><span class="title function_">animalSound</span>(cat); <span class="comment">// Output: &quot;Meow!&quot; (Cat&#x27;s sound)</span></span><br></pre></td></tr></table></figure><ul><li><p>通过<code>MathOperations</code>类中的方法重载演示<code>编译时多态性</code>。</p><p>定义了两个版本的<code>add</code>方法：一个用于数字加法，另一个用于字符串连接。在编译时根据函数调用期间使用的参数类型选择适当的方法。</p></li><li><p>通过<code>Animal</code>、<code>Dog</code>和<code>Cat</code>类中的方法覆盖来演示<code>运行时多态性</code>。</p><p><code>Animal</code>类具有提供通用声音的<code>makeSound</code>方法。<code>Dog</code>和<code>Cat</code>类都会重写<code>makeSound</code>方法以提供其特定的声音。当使用<code>Dog</code>和<code>Cat</code>的不同对象调用<code>animalSound</code>函数时，适当的<code>makeSound</code>方法将在运行时根据实际对象的类型动态确定。</p></li></ul><p>多态性允许根据对象的公共接口而不是其特定类型来处理对象，从而编写更灵活和可扩展的代码。</p><br><h1 id="基本用法">3. 基本用法</h1><blockquote style="border-left:4px solid #6495ed;background-color:#f5f5f5;padding:25px 20px 10px;position:relative;margin-top:20px"><div style="position:absolute;top:-15px;left:-10px;background-color:#6495ed;color:#fff;padding:5px 10px;border-radius:3px;font-size:.8em;font-weight:700;box-shadow:0 2px 5px rgba(0,0,0,.1)">引用 & 扩展</div>&#42; <a href="https://wangdoc.com/typescript/" target="_blank">TypeScript 教程</a><br>&#42; <a href="https://www.typescriptlang.org/play/" target="_blank">官网在线编译, 将 TypeScript 编译为 JavaScript</a><br></blockquote><h2 id="类型声明">3.1. 类型声明</h2><p>TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo = 100; // TS2322: Type number is not assignable to type string</span></span><br></pre></td></tr></table></figure><p>示例中，变量<code>foo</code>的后面使用冒号，声明了它的类型为<code>string</code>。</p><p>类型声明的写法，一律为在标识符后面添加“冒号 + 类型”。函数参数和返回值，也是这样来声明类型。如果变量的值应该与声明的类型一致，如果不一致，TypeScript 就会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">person: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello: &quot;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayHello</span>(<span class="string">&#x27;Tom&#x27;</span>)) <span class="comment">// Hello: Tom </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">toString</span>(<span class="number">1000</span>)) <span class="comment">// &quot;1000&quot;</span></span><br></pre></td></tr></table></figure><p>示例中，函数<code>toString()</code>的参数<code>num</code>的类型是<code>number</code>。参数列表的圆括号后面，声明了返回值的类型是<code>string</code>。</p><br><h2 id="类型推断">3.2. 类型推断</h2><p>类型声明并不是必需的，如果没有，TypeScript 会自己推断类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">foo = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// TS2322: Type string is not assignable to type number</span></span><br></pre></td></tr></table></figure><p>示例中，变量<code>foo</code>并没有类型声明，TypeScript 就会推断它的类型。由于它被赋值为一个数值，因此 TypeScript 推断它的类型为<code>number</code>。</p><p>如果变量<code>foo</code>更改为其他类型的值，跟推断的类型不一致，TypeScript 就会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">toString</span>(<span class="number">1000</span>)) <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>TypeScript 也可以推断函数的返回值。示例中，函数<code>toString()</code>没有声明返回值的类型，但是 TypeScript 推断返回的是字符串。正是因为 TypeScript 的类型推断，所以函数返回值的类型通常是省略不写的。</p><p>从这里可以看到，TypeScript 的设计思想是，类型声明是可选的，你可以加，也可以不加。即使不加类型声明，依然是有效的 TypeScript 代码，只是这时不能保证 TypeScript 会正确推断出类型。由于这个原因，<b>所有 JavaScript 代码都是合法的 TypeScript 代码</b>。</p><p>这样设计还有一个好处，将以前的 JavaScript 项目改为 TypeScript 项目时，你可以逐步地为老代码添加类型，即使有些代码没有添加，也不会无法运行。</p><br><h2 id="编译">3.3. 编译</h2><p>JavaScript 的运行环境（浏览器和 Node.js）不认识 TypeScript 代码。所以，TypeScript 项目要想运行，必须先转为 JavaScript 代码，这个代码转换的过程就叫做“编译”（compile）。</p><p>TypeScript 官方没有做运行环境，只提供编译器。编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。</p><p>因此，<b>TypeScript 的类型检查只是编译时的类型检查，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了</b>。</p><br><h1 id="数据结构">4. 数据结构</h1><h2 id="三种特殊类型">4.1. 三种特殊类型</h2><h3 id="any">4.1.1. any</h3><div class="spoiler collapsed"><div class="spoiler-title">any</div><div class="spoiler-content"><p>any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 编译正确</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;foo&#x27;</span>; <span class="comment">// 编译正确</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// foo </span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 编译正确</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>示例中，变量<code>x</code>的类型是<code>any</code>，就可以被赋值为任意类型的值。</p><p><b>变量类型一旦设为<code>any</code>，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错</b>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="title function_">x</span>(<span class="number">1</span>) <span class="comment">// 不报错</span></span><br><span class="line">x.<span class="property">foo</span> = <span class="number">100</span>; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><p>示例中，变量<code>x</code>的值是一个字符串，但是把它当作函数调用，或者当作对象读取任意属性，TypeScript 编译时都不报错。原因就是<code>x</code>的类型是<code>any</code>，TypeScript 不对其进行类型检查。</p><p>由于这个原因，<b>应该尽量避免使用<code>any</code>类型，否则就失去了使用 TypeScript 的意义</b>。</p><ul><li><p>污染问题</p><p><code>any</code>类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 不报错</span></span><br><span class="line"></span><br><span class="line">y * <span class="number">123</span> <span class="comment">// 不报错</span></span><br><span class="line">y.<span class="title function_">toFixed</span>() <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><p>示例中，变量<code>x</code>的类型是<code>any</code>，实际的值是一个字符串。变量<code>y</code>的类型是<code>number</code>，表示这是一个数值变量，但是它被赋值为<code>x</code>，这时并不会报错。然后，变量<code>y</code>继续进行各种数值运算，TypeScript 也检查不出错误，问题就这样留到运行时才会暴露。</p><p><b>污染其他具有正确类型的变量，把错误留到运行时，这就是不宜使用<code>any</code>类型的另一个主要原因</b>。</p></li></ul></div></div><br><h3 id="unknown">4.1.2. unknown</h3><div class="spoiler collapsed"><div class="spoiler-title">unknown</div><div class="spoiler-content"><p>为了解决<code>any</code>类型“污染”其他变量的问题，TypeScript 3.0 引入了<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type"><code>unknown</code>类型</a>。它与<code>any</code>含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像<code>any</code>那样自由，可以视为严格版的<code>any</code>。</p><p><b><code>unknown</code>跟<code>any</code>的相似之处，在于所有类型的值都可以分配给<code>unknown</code>类型</b>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">unknown</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="number">42</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;Hello World&#x27;</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>示例中，变量<code>x</code>的类型是<code>unknown</code>，可以赋值为各种类型的值。这与<code>any</code>的行为一致。</p><p><b><code>unknown</code>类型跟<code>any</code>类型的不同之处在于，它不能直接使用</b>。主要有以下几个限制：</p><ul><li><p><b><code>unknown</code>类型的变量，不能直接赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）</b>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v</span>:<span class="built_in">unknown</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">boolean</span> = v; <span class="comment">// TS2322: Type unknown is not assignable to type boolean</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">number</span> = v; <span class="comment">// TS2322: Type unknown is not assignable to type number</span></span><br></pre></td></tr></table></figure><p>示例中，变量<code>v</code>是<code>unknown</code>类型，赋值给<code>any</code>和<code>unknown</code>以外类型的变量都会报错，这就避免了污染问题，从而克服了<code>any</code>类型的一大缺点。</p></li><li><p><b>不能直接调用<code>unknown</code>类型变量的方法和属性</b></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">unknown</span> = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">v1.<span class="property">foo</span>  <span class="comment">// TS2339: Property foo does not exist on type unknown</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">v2.<span class="title function_">trim</span>() <span class="comment">// TS2339: Property trim does not exist on type unknown</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v3</span>:<span class="built_in">unknown</span> = <span class="function">(<span class="params">n = <span class="number">0</span></span>) =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="title function_">v3</span>() <span class="comment">// TS2349: This expression is not callable. Type &#123;&#125; has no call signatures.</span></span><br></pre></td></tr></table></figure><p>示例中，直接调用<code>unknown</code>类型变量的属性和方法，或者直接当作函数执行，都会报错。</p></li><li><p><b><code>unknown</code>类型变量能够进行的运算是有限的</b></p><p><code>unknown</code>类型变量只能进行比较运算（运算符<code>==</code>、<code>===</code>、<code>!=</code>、<code>!==</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code>）、取反运算（运算符<code>!</code>）、<code>typeof</code>运算符和<code>instanceof</code>运算符这几种，其他运算都会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">unknown</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a + <span class="number">1</span> <span class="comment">// TS2365: Operator + cannot be applied to types unknown and 1</span></span><br><span class="line">a === <span class="number">1</span> <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>示例中，<code>unknown</code>类型的变量<code>a</code>进行加法运算会报错，因为这是不允许的运算。但是，进行比较运算就是可以的。</p></li></ul></div></div><br><h4 id="类型缩小">4.1.2.1. 类型缩小</h4><div class="spoiler collapsed"><div class="spoiler-title">类型缩小</div><div class="spoiler-content"><p>怎么才能使用<code>unknown</code>类型变量呢？</p><p>只有经过“类型缩小”，才能使用<code>unknown</code>类型变量。所谓“类型缩小”，就是缩小<code>unknown</code>变量的类型范围，确保不会出错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">unknown</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = a + <span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中，<code>unknown</code>类型的变量<code>a</code>经过<code>typeof</code>运算以后，能够确定实际类型是<code>number</code>，就能用于加法运算了。这就是“类型缩小”，即将一个不确定的类型缩小为更明确的类型。</p><p>下面是另一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="built_in">unknown</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> s === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    s.<span class="property">length</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中，确定变量<code>s</code>的类型为字符串以后，才能调用它的<code>length</code>属性。</p><p>这样设计的目的是，只有明确<code>unknown</code>变量的实际类型，才允许使用它，防止像<code>any</code>那样可以随意乱用，“污染”其他变量。类型缩小以后再使用，就不会报错。</p><hr><p>OP 常年使用 Java 开发后端，刚写到这里其实有些懵。<br>上面的例子中，并没有改变 a&#x2F;s 变量的实际类型，a&#x2F;s 变量还是 unknown 类型，为什么 typeof 后在 if 分支中就允许操作呢？</p><p>由于 OP 代入了 Java 的视角，在 Java 中，当通过<code>instanceof</code>判断某一类型后，通常会直接进行类型转换，然后才会继续操作，比如下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (data <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> (Integer) data;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到上面的问题：为什么 typeof 后在 if 分支中就可以操作？</p><p>答案在于 TypeScript 的类型系统通过 typeof 检查，<b>在静态分析时确认了 a 在 if 分支内的类型是安全的</b>，具体来说：</p><ul><li><p><code>typeof a === &#39;number&#39;</code>确保 a 的运行时类型是 JavaScript 的 number。</p></li><li><p>TypeScript 知道 JavaScript 的 number 类型对应于 TypeScript 的 number 类型，因此在该分支内，a 被安全地视为 number。</p></li><li><p>number 类型支持数学运算（如 +），因此 a + 10 是合法的。</p></li><li><p>如果 typeof 检查是其他类型（如 string），TypeScript 会根据具体类型决定允许的操作。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">aaa</span>: <span class="built_in">unknown</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> aaa === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = aaa.<span class="title function_">toUpperCase</span>(); <span class="comment">// 合法，因为 string 支持 toUpperCase</span></span><br><span class="line">    <span class="keyword">let</span> r2 = aaa + <span class="number">10</span>; <span class="comment">// 合法，但结果是字符串拼接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但在 if 分支外，TypeScript 无法确定 a 的具体类型，因此仍然将其视为 unknown，禁止任何操作。</p><p>除了 typeof 检查，TypeScript 还支持多种类型缩小的方式，可以安全地操作 unknown 类型变量。</p><ul><li><p>instanceof 检查</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">unknown</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">getTime</span>()); <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于检查变量是否是某个类的实例，类似于 Java 的 instanceof。</p></li><li><p>属性检查（in 运算符）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">unknown</span> = &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="string">&quot;name&quot;</span> <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>); <span class="comment">// 合法，TypeScript 推断 a 具有 name 属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></div></div><br><h3 id="never">4.1.3. never</h3><div class="spoiler collapsed"><div class="spoiler-title">never</div><div class="spoiler-content"><p>为了保持与集合论的对应关系，以及类型运算的完整性，TypeScript 还引入了”空类型”的概念，即该类型为空，不包含任何值。</p><p>由于不存在任何属于“空类型”的值，所以该类型被称为<code>never</code>，即不可能有这样的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">never</span>;</span><br><span class="line">x = <span class="number">100</span>; <span class="comment">// TS2322: Type number is not assignable to type never</span></span><br></pre></td></tr></table></figure><p>示例中，变量<code>x</code>的类型是<code>never</code>，就不可能赋给它任何值，否则都会报错。</p><p><code>never</code>类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性。</p><p>另外，不可能返回值的函数，返回值的类型就可以写成<code>never</code>。</p><p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。这时，处理所有可能的类型之后，剩余的情况就属于<code>never</code>类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">string</span>|<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x; <span class="comment">// never 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中，参数变量<code>x</code>可能是字符串，也可能是数值，判断了这两种情况后，剩下的最后那个<code>else</code>分支里面，<code>x</code>就是<code>never</code>类型了。</p></div></div><br><h2 id="类型系统">4.2. 类型系统</h2><h3 id="基本类型">4.2.1. 基本类型</h3><p>JavaScript 语言将值分成8种类型：boolean、string、number、bigint、symbol、object、undefined、null。</p><p>TypeScript 继承了 JavaScript 的类型设计，以上8种类型可以看作 TypeScript 的基本类型。</p><ul><li><div class="spoiler collapsed"><div class="spoiler-title">boolean 类型</div><div class="spoiler-content"><p><code>boolean</code>类型只包含<code>true</code>和<code>false</code>两个布尔值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>示例中，变量<code>x</code>和<code>y</code>就属于 boolean 类型。</p></div></div><br></li><li><div class="spoiler collapsed"><div class="spoiler-title">string 类型</div><div class="spoiler-content"><p><code>string</code>类型包含所有字符串。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">string</span> = <span class="string">`<span class="subst">$&#123;x&#125;</span> world`</span>;</span><br></pre></td></tr></table></figure><p>示例中，普通字符串和模板字符串都属于 string 类型。</p></div></div><br></li><li><div class="spoiler collapsed"><div class="spoiler-title">number 类型</div><div class="spoiler-content"><p><code>number</code>类型包含所有整数和浮点数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">number</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">z</span>:<span class="built_in">number</span> = <span class="number">0xffff</span>;</span><br></pre></td></tr></table></figure><p>示例中，整数、浮点数和非十进制数都属于 number 类型。</p></div></div><br></li><li><div class="spoiler collapsed"><div class="spoiler-title">bigint 类型</div><div class="spoiler-content"><p>bigint 类型包含所有的大整数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">bigint</span> = <span class="number">123n</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">bigint</span> = <span class="number">0xffffn</span>;</span><br></pre></td></tr></table></figure><p>示例中，变量<code>x</code>和<code>y</code>就属于 bigint 类型。</p><p>注意：bigint 与 number 类型不兼容。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">bigint</span> = <span class="number">123</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">bigint</span> = <span class="number">3.14</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>示例中，<code>bigint</code>类型赋值为整数和小数，都会报错。</p><p>注意，bigint 类型是 ES2020 标准引入的。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于 ES2020（即编译参数<code>target</code>不低于<code>es2020</code>）。</p></div></div><br></li><li><div class="spoiler collapsed"><div class="spoiler-title">symbol 类型</div><div class="spoiler-content"><p>symbol 类型包含所有的 Symbol 值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure><p>示例中，<code>Symbol()</code>函数的返回值就是 symbol 类型。</p><p>待完善…</p></div></div><br></li><li><div class="spoiler collapsed"><div class="spoiler-title">object 类型</div><div class="spoiler-content"><p>根据 JavaScript 的设计，object 类型包含了所有对象、数组和函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="built_in">object</span> = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">object</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">z</span>:<span class="built_in">object</span> = <span class="function">(<span class="params">n:<span class="built_in">number</span></span>) =&gt;</span> n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>示例中，对象、数组、函数都属于 object 类型。</p></div></div><br></li><li><div class="spoiler collapsed"><div class="spoiler-title">undefined 和 null 类型</div><div class="spoiler-content"><p>undefined 和 null 是两种独立类型，它们各自都只有一个值。</p><p>undefined 类型只包含一个值<code>undefined</code>，表示未定义（即还未给出定义，以后可能会有定义）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>示例中，变量<code>x</code>就属于 undefined 类型。两个<code>undefined</code>里面，第一个是类型，第二个是值。</p><p>null 类型也只包含一个值<code>null</code>，表示为空（即此处没有值）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>示例中，变量<code>x</code>就属于 null 类型。</p></div></div></li></ul><br><h3 id="包装对象">4.2.2. 包装对象</h3><p>JavaScript 的8种类型之中，<code>undefined</code>和<code>null</code>其实是两个特殊值，<code>object</code>属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。</p><p>boolean、string、number、bigint、symbol 这五种原始类型的值，都有对应的包装对象（wrapper object）。</p><p>五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即<code>Symbol()</code>和<code>BigInt()</code>不能作为构造函数使用），但是剩下三种可以：<code>Boolean()</code>、<code>String()</code>、<code>Number()</code>。</p><p>以上三个构造函数，执行后可以直接获取某个原始类型值的包装对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">typeof</span> s <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line">s.<span class="title function_">charAt</span>(<span class="number">1</span>) <span class="comment">// &#x27;e&#x27;</span></span><br></pre></td></tr></table></figure><p>示例中，<code>s</code>就是字符串<code>hello</code>的包装对象，<code>typeof</code>运算符返回<code>object</code>，不是<code>string</code>，但是本质上它还是字符串，可以使用所有的字符串方法。</p><p>注意，<code>String()</code>只有当作构造函数使用时（即带有<code>new</code>命令调用），才会返回包装对象。如果当作普通函数使用（不带有<code>new</code>命令），返回就是一个普通字符串。其他两个构造函数<code>Number()</code>和<code>Boolean()</code>也是如此。</p><br><h4 id="包装对象与字面量">4.2.2.1. 包装对象与字面量</h4><p>由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello&#x27;</span> <span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 包装对象</span></span><br></pre></td></tr></table></figure><p>示例中，第一行是字面量，第二行是包装对象，它们都是字符串。</p><p>为了区分这两种情况，TypeScript 对五种原始类型分别提供了大写和小写两种类型。Boolean 和 boolean、String 和 string、Number 和 number、BigInt 和 bigint、Symbol 和 symbol。</p><p>其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="title class_">String</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="title class_">String</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s3</span>:<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s4</span>:<span class="built_in">string</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 报错,TS2322: Type String is not assignable to type string</span></span><br></pre></td></tr></table></figure><p>示例中，<code>String</code>类型可以赋值为字符串的字面量，也可以赋值为包装对象。但是，<code>string</code>类型只能赋值为字面量，赋值为包装对象就会报错。</p><p>建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">n1</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">n2</span>:<span class="title class_">Number</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(n1) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(n2) <span class="comment">// 报错,TS2345: Argument of type Number is not assignable to parameter of type number</span></span><br></pre></td></tr></table></figure><p>示例中，<code>Math.abs()</code>方法的参数类型被定义成小写的<code>number</code>，传入大写的<code>Number</code>类型就会报错。</p><br><h3 id="Object-与-object">4.2.3. Object 与 object</h3><p>TypeScript 的对象类型也有大写<code>Object</code>和小写<code>object</code>两种。</p><h4 id="Object类型">4.2.3.1. Object类型</h4><p>大写的<code>Object</code>类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是<code>Object</code>类型，这囊括了几乎所有的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="title class_">Object</span>;</span><br><span class="line"> </span><br><span class="line">obj = <span class="literal">true</span>;</span><br><span class="line">obj = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">obj = <span class="number">1</span>;</span><br><span class="line">obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">obj = <span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>示例中，原始类型值、对象、数组、函数都是合法的<code>Object</code>类型。</p><p>事实上，除了<code>undefined</code>和<code>null</code>这两个值不能转为对象，其他任何值都可以赋值给<code>Object</code>类型。</p><p>空对象<code>&#123;&#125;</code>是<code>Object</code>类型的简写形式，所以使用<code>Object</code>时常常用空对象代替。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">obj = <span class="literal">true</span>;</span><br><span class="line">obj = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">obj = <span class="number">1</span>;</span><br><span class="line">obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">obj = <span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>示例中，变量<code>obj</code>的类型是空对象<code>&#123;&#125;</code>，就代表<code>Object</code>类型。显然，无所不包的<code>Object</code>类型既不符合直觉，也不方便使用。</p><br><h4 id="object-类型">4.2.3.2. object 类型</h4><p>小写的<code>object</code>类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="built_in">object</span>;</span><br><span class="line"></span><br><span class="line">obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">obj = <span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line">obj = <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line">obj = <span class="string">&#x27;hi&#x27;</span>; <span class="comment">// 报错</span></span><br><span class="line">obj = <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>示例中，<code>object</code>类型不包含原始类型值，只包含对象、数组和函数。</p><p>大多数时候，使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，<b>建议总是使用小写类型<code>object</code>，不使用大写类型<code>Object</code></b>。</p><p>注意，无论是大写的<code>Object</code>类型，还是小写的<code>object</code>类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">o1</span>:<span class="title class_">Object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">o2</span>:<span class="built_in">object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.<span class="title function_">toString</span>() <span class="comment">// 正确</span></span><br><span class="line">o1.<span class="property">foo</span> <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">o2.<span class="title function_">toString</span>() <span class="comment">// 正确</span></span><br><span class="line">o2.<span class="property">foo</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>示例中，<code>toString()</code>是对象的原生方法，可以正确访问。<code>foo</code>是自定义属性，访问就会报错。</p><br><h3 id="值类型">4.2.4. 值类型</h3><p>TypeScript 支持将单个具体值作为类型，称为“值类型”（也叫字面量类型，Literal Types）。值类型限制变量只能赋值为指定的值。<br>例如，字符串 “hello”、数字 42、布尔值 true 都可以作为类型。这种类型限制变量只能赋值为指定的值，无法赋值为其他值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 显式指定类型为 &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// 报错, Type &quot;world&quot; is not assignable to type &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>示例中，<code>let x: &#39;hello&#39;</code>显式指定了字面量类型 ‘hello’，因此 x 只能赋值为 “hello”，赋值为任何其他值（包括其他字符串）都会导致类型错误。</p><p>TypeScript 推断类型时，遇到<code>const</code>命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。这是因为<code>const</code>变量不可重新赋值，字面量类型能精确描述其值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 的类型是 &quot;https&quot;</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="string">&#x27;https&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y 的类型是 string</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">string</span> = <span class="string">&#x27;https&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>示例中，变量<code>x</code>是<code>const</code>命令声明的，TypeScript 就会推断它的类型是值<code>https</code>，而不是<code>string</code>类型。</li><li>变量<code>y</code>显式指定了类型为<code>string</code>，因此可以赋值为任何字符串。</li></ul><p>这种推断是合理的，因为<code>const</code>声明的变量一旦赋值就不可更改，相当于常量，字面量类型能最大化类型安全性。</p><hr style="height:2px;border-width:0;color:red;background-color:#008b45"><p>与 const 不同，let 声明的变量是可变的。如果没有显式指定类型，TypeScript 会推断为更宽泛的类型（如 string、number），而不是字面量类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = <span class="string">&#x27;https&#x27;</span>; <span class="comment">// 推断为类型 string</span></span><br><span class="line">z = <span class="string">&#x27;http&#x27;</span>; <span class="comment">// 正确：z 是 string 类型</span></span><br><span class="line">z = <span class="string">&#x27;ftp&#x27;</span>; <span class="comment">// 正确：z 是 string 类型</span></span><br></pre></td></tr></table></figure><p>示例中，变量 z 没有显式类型注解，TypeScript 推断其类型为<code>string</code>，因此可以赋值为任何字符串。</p><p>但是，如果显式指定字面量类型，let 变量会被限制为值类型，与前面的<code>let x: &#39;hello&#39;</code>示例一致：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">w</span>: <span class="string">&#x27;https&#x27;</span> = <span class="string">&#x27;https&#x27;</span>; <span class="comment">// 显式指定类型为 &#x27;https&#x27;</span></span><br><span class="line">w = <span class="string">&#x27;https&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">w = <span class="string">&#x27;http&#x27;</span>; <span class="comment">// 报错：Type &#x27;&quot;http&quot;&#x27; is not assignable to type &#x27;&quot;https&quot;&#x27;</span></span><br></pre></td></tr></table></figure><hr style="height:2px;border-width:0;color:red;background-color:#008b45"><p>注意，<code>const</code>声明的变量如果赋值为对象，TypeScript 不会推断为值类型，而是推断为对象的结构类型。这是因为<code>const</code>只限制变量引用不可变，对象的内容（属性值）仍然可以改变。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;; <span class="comment">// 推断为 &#123; name: string &#125;</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Bob&#x27;</span>; <span class="comment">// 正确：name 是 string 类型</span></span><br></pre></td></tr></table></figure><p>如果需要将对象及其属性推断为字面量类型，可以使用 as const 断言：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 推断为 &#123; readonly name: &#x27;Alice&#x27; &#125;</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Bob&#x27;</span>; <span class="comment">// 报错：Cannot assign to &#x27;name&#x27; because it is a readonly property</span></span><br></pre></td></tr></table></figure><br><h2 id="数组">4.3. 数组</h2><p>TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。</p><p>数组的类型有两种写法：</p><ul><li><p>第一种，数组成员的类型后面，加上一对方括号。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>示例中，数组<code>arr</code>的类型是<code>number[]</code>，其中<code>number</code>表示数组成员类型是<code>number</code>。</p><p>如果数组成员的类型比较复杂，可以写在圆括号里面。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:(<span class="built_in">number</span>|<span class="built_in">string</span>)[];</span><br></pre></td></tr></table></figure><p>示例中，数组<code>arr</code>的成员类型是<code>number|string</code>。</p><blockquote><p>这个例子里面的圆括号是必须的，否则因为竖杠<code>|</code>的优先级低于<code>[]</code>，TypeScript 会把<code>number|string[]</code>理解成<code>number</code>和<code>string[]</code>的联合类型。</p></blockquote></li><li><p>第二种，使用 TypeScript 内置的 Array 接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>示例中，数组<code>arr</code>的类型是<code>Array&lt;number&gt;</code>，其中<code>number</code>表示成员类型是<code>number</code>。这种写法对于成员类型比较复杂的数组，代码可读性会稍微好一些。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>|<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure><p>这种写法本质上属于泛型。</p></li></ul><p>数组类型声明了以后，成员数量是不限制的，任意数量的成员都可以，也可以是空数组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[];</span><br><span class="line">arr = [];</span><br><span class="line">arr = [<span class="number">1</span>];</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>示例中，数组<code>arr</code>无论有多少个成员，都是正确的。这种规定的隐藏含义就是，<b>数组的成员是可以动态变化的</b>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">arr.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>示例中，数组增加成员或减少成员，都是可以的。正是由于成员数量可以动态变化，所以 <b>TypeScript 不会对数组边界进行检查，越界访问数组并不会报错</b>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> foo = arr[<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>示例中，变量<code>foo</code>的值是一个不存在的数组成员，TypeScript 并不会报错。</p><p>TypeScript 允许使用方括号读取数组成员的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Names</span>[<span class="number">0</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>示例中，类型<code>Names</code>是字符串数组，那么<code>Names[0]</code>返回的类型就是<code>string</code>。</p><p>由于数组成员的索引类型都是<code>number</code>，所以读取成员类型也可以写成下面这样。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Names</span>[<span class="built_in">number</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>示例中，<code>Names[number]</code>表示数组<code>Names</code>所有数值索引的成员类型，所以返回<code>string</code>。</p><br><h2 id="元组">4.4. 元组</h2><p>元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有单独区分这种类型。它表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。</p><p>由于成员的类型可以不一样，所以元组必须明确声明每个成员的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s</span>:[<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure><p>示例中，元组<code>s</code>的前两个成员的类型是<code>string</code>，最后一个成员的类型是<code>boolean</code>。</p><p>元组类型的写法，数组有一个重大差异。数组的成员类型写在方括号外面（<code>number[]</code>），元组的成员类型是写在方括号里面（<code>[number]</code>）。TypeScript 的区分方法就是，成员类型写在方括号里面的就是元组，写在外面的就是数组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">t</span>:[<span class="built_in">number</span>] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>示例中，变量<code>a</code>和<code>t</code>的值都是<code>[1]</code>，但是它们的类型是不一样的。<code>a</code>是一个数组，成员类型<code>number</code>写在方括号外面；<code>t</code>是一个元组，成员类型<code>number</code>写在方括号里面。</p><p>使用元组时，必须明确给出类型声明（上例的<code>[number]</code>），不能省略，否则 TypeScript 会把一个值自动推断为数组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 的类型被推断为 (number | boolean)[]</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure><p>示例中，变量<code>a</code>的值其实是一个元组，但是 TypeScript 会将其推断为一个联合类型的数组，即<code>a</code>的类型为<code>(number | boolean)[]</code>。所以，元组必须显式给出类型声明。</p><p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:[<span class="built_in">number</span>, <span class="built_in">number</span>?] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>示例中，元组<code>a</code>的第二个成员是可选的，可以省略。注意，问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myTuple = [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>?, <span class="built_in">string</span>?];</span><br></pre></td></tr></table></figure><p>示例中，元组<code>myTuple</code>的最后两个成员是可选的。也就是说，它的成员数量可能有两个、三个和四个。</p><p>由于需要声明每个成员的类型，所以大多数情况下，元组的成员数量是有限的，从类型声明就可以明确知道，元组包含多少个成员，越界的成员会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:[<span class="built_in">string</span>, <span class="built_in">string</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">x[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>; <span class="comment">// 报错, Type &quot;c&quot; is not assignable to type undefined</span></span><br></pre></td></tr></table></figure><p>示例中，变量<code>x</code>是一个只有两个成员的元组，如果对第三个成员赋值就报错了。但是，使用扩展运算符（<code>...</code>），可以表示不限成员数量的元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NamedNums</span> = [</span><br><span class="line">    <span class="built_in">string</span>,</span><br><span class="line">    ...<span class="built_in">number</span>[]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="title class_">NamedNums</span> = [<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">NamedNums</span> = [<span class="string">&#x27;B&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [ &#x27;A&#x27;, 1, 2 ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [ &#x27;B&#x27;, 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><p>示例中，元组类型<code>NamedNums</code>的第一个成员是字符串，后面的成员使用扩展运算符来展开一个数组，从而实现了不定数量的成员。</p><p>扩展运算符（<code>...</code>）用在元组的任意位置都可以，它的后面只能是一个数组或元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]];</span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">string</span>, ...<span class="built_in">boolean</span>[], <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t3 = [...<span class="built_in">boolean</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure><p>示例中，扩展运算符分别在元组的尾部、中部和头部，<code>...</code>的后面是一个数组<code>boolean[]</code>。</p><p>元组的成员可以添加成员名，这个成员名是说明性的，可以任意取名，没有实际作用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = [</span><br><span class="line">    <span class="attr">red</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">green</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">blue</span>: <span class="built_in">number</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>:<span class="title class_">Color</span> = [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// [ 255, 255, 255 ]</span></span><br></pre></td></tr></table></figure><p>元组可以通过方括号，读取成员类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Tuple</span>[<span class="number">1</span>]; <span class="comment">// number</span></span><br></pre></td></tr></table></figure><p>示例中，<code>Tuple[1]</code>返回1号位置的成员类型。</p><p>由于元组的成员都是数值索引，即索引类型都是<code>number</code>，所以可以像下面这样读取。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="title class_">Date</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TupleEl</span> = <span class="title class_">Tuple</span>[<span class="built_in">number</span>];  <span class="comment">// string|number|Date</span></span><br></pre></td></tr></table></figure><p>示例中，<code>Tuple[number]</code>表示元组<code>Tuple</code>的所有数值索引的成员类型，所以返回<code>string|number|Date</code>，即这个类型是三种值的联合类型。</p><br><h1 id="函数">5. 函数</h1><p>函数的类型声明，需要在声明函数时，给出参数的类型和返回值的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">txt: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hello</span>(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello2</span>(<span class="params">txt: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello &#x27;</span> + txt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hello2</span>(<span class="string">&#x27;world&#x27;</span>)); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure><p>示例中，函数<code>hello()</code>在声明时，需要给出参数<code>txt</code>的类型（string），以及返回值的类型（<code>void</code>），后者写在参数列表的圆括号后面。<code>void</code>类型表示没有返回值，详见后文。</p><p>如果不指定参数类型（比如上例不写<code>txt</code>的类型），TypeScript 就会推断参数类型，如果缺乏足够信息，就会推断该参数的类型为<code>any</code>。</p><p>返回值的类型通常可以不写，因为 TypeScript 自己会推断出来。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无返回值类型,推断 void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello1</span>(<span class="params">txt:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，由于没有<code>return</code>语句，TypeScript 会推断出函数<code>hello1()</code>没有返回值。</p><hr style="height:2px;border-width:0;color:red;background-color:#008b45"><p>如果变量被赋值为一个函数，变量的类型有两种写法：</p><ul><li><p>写法一</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span> (<span class="params">txt: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hello</span>(<span class="string">&#x27;world&#x27;</span>);</span><br></pre></td></tr></table></figure><p>通过等号右边的函数类型，推断出变量<code>hello</code>的类型。</p></li><li><p>写法二：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>: <span class="function">(<span class="params">txt: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> = <span class="keyword">function</span> (<span class="params">txt</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">hello</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// const helloAction = function hello3(txt: string): string &#123;</span></span><br><span class="line"><span class="comment">//     return &#x27;Hello &#x27; + txt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log(helloAction(&#x27;world&#x27;));</span></span><br></pre></td></tr></table></figure><p>使用箭头函数的形式，显式指定变量<code>hello</code>的类型为函数，而<code>(txt: string) =&gt; void</code>表示一个接受字符串参数、无返回值的函数，参数的类型写在箭头左侧，返回值的类型写在箭头右侧。</p><p>写法二有两个地方需要注意。</p><p>首先，函数的参数要放在圆括号里面，不放会报错。</p><p>其次，类型里面的参数名（本例是<code>txt</code>）是必须的。有的语言的函数类型可以不写参数名（比如 C 语言），但是 TypeScript 不行。如果写成<code>(string) =&gt; void</code>，TypeScript 会理解成函数有一个名叫 string 的参数，并且这个<code>string</code>参数的类型是<code>any</code>。</p></li></ul><p>如果函数的类型定义很冗长，或者多个函数使用同一种类型，写法二用起来就很麻烦。因此，往往用<code>type</code>命令为函数类型定义一个别名，便于指定给其他变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyFunc</span> = <span class="function">(<span class="params">txt: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>: <span class="title class_">MyFunc</span> = <span class="keyword">function</span> (<span class="params">txt</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">hello</span>(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>type</code>命令为函数类型定义了一个别名<code>MyFunc</code>，后面使用就很方便，变量可以指定为这个类型。</p><hr style="height:2px;border-width:0;color:red;background-color:#008b45"><p>函数的实际参数个数，可以少于类型指定的参数个数，但是不能多于，即 TypeScript 允许省略参数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">myFunc = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> a; <span class="comment">// 正确(参数不足)</span></span><br><span class="line"></span><br><span class="line">myFunc = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>) =&gt;</span> a + b + c; <span class="comment">// 报错(参数多了)</span></span><br></pre></td></tr></table></figure><p>上面示例中，变量<code>myFunc</code>的类型只能接受两个参数，如果被赋值为只有一个参数的函数，并不报错。但是，被赋值为有三个参数的函数，就会报错。</p><p>这是因为 JavaScript 函数在声明时往往有多余的参数，实际使用时可以只传入一部分参数。比如，数组的<code>forEach()</code>方法的参数是一个函数，该函数默认有三个参数<code>(item, index, array) =&gt; void</code>，实际上往往只使用第一个参数<code>(item) =&gt; void</code>。因此，TypeScript 允许函数传入的参数不足。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">x</span> = (<span class="params">a:<span class="built_in">number</span></span>) =&gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">y</span> = (<span class="params">b:<span class="built_in">number</span>, s:<span class="built_in">string</span></span>) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 正确</span></span><br><span class="line">x = y; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面示例中，函数<code>x</code>只有一个参数，函数<code>y</code>有两个参数，<code>x</code>可以赋值给<code>y</code>，反过来就不行。</p><hr style="height:2px;border-width:0;color:red;background-color:#008b45"><p>如果一个变量要套用另一个函数类型，有一个小技巧，就是使用<code>typeof</code>运算符。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">myAdd</span>: <span class="keyword">typeof</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，函数<code>myAdd()</code>的类型与函数<code>add()</code>是一样的，那么就可以定义成<code>typeof add</code>。因为函数名<code>add</code>本身不是类型，而是一个值，所以要用<code>typeof</code>运算符返回它的类型。</p><p>这是一个很有用的技巧，任何需要类型的地方，都可以使用<code>typeof</code>运算符从一个值获取类型。</p><br><h2 id="函数类型">5.1. 函数类型</h2><p>TypeScript 提供 Function 类型表示函数，任何函数都属于这个类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">f:<span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，参数<code>f</code>的类型就是<code>Function</code>，代表这是一个函数。</p><p>Function 类型的值都可以直接执行。</p><p>Function 类型的函数可以接受任意数量的参数，每个参数的类型都是<code>any</code>，返回值的类型也是<code>any</code>，代表没有任何约束，所以<b>不建议使用这个类型</b>，给出函数详细的类型声明会更好。</p><br><h2 id="箭头函数">5.2. 箭头函数</h2><p>箭头函数是普通函数的一种简化写法，它的类型写法与普通函数类似。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> repeat = (<span class="attr">str</span>: <span class="built_in">string</span>, <span class="attr">times</span>: <span class="built_in">number</span>): <span class="function"><span class="params">string</span> =&gt;</span> str.<span class="title function_">repeat</span>(times);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">repeat</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">2</span>)); <span class="comment">// 输出：abcabc</span></span><br></pre></td></tr></table></figure><p>在上面的示例中：</p><ul><li>变量<code>repeat</code>被赋值为一个箭头函数。</li><li>参数类型<code>str: string</code>和<code>times: number</code>写在参数名后。</li><li>返回值类型 :<code>string</code>写在参数列表<code>()</code>后、箭头<code>=&gt;</code>前。</li><li>TypeScript 推断<code>repeat</code>的类型为<code>(str: string, times: number) =&gt; string</code>。</li></ul><p>注意，类型写在箭头函数的定义里面，与使用箭头函数表示函数类型，写法有所不同。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">fn: (a: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="function">(<span class="params">msg</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + msg)); <span class="comment">// 输出：Hello, world</span></span><br></pre></td></tr></table></figure><p>在上面的示例中：</p><ul><li>函数<code>greet</code>的参数<code>fn</code>是一个函数类型<code>(a: string) =&gt; void</code>。</li><li><code>(a: string) =&gt; void</code>表示：<code>fn</code>接受一个字符串参数，无返回值。</li><li>返回值类型<code>void</code>写在箭头<code>=&gt;</code>右侧，与箭头函数定义的<code>: void</code>（写在 () 后）不同。</li></ul><p>下面再看一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;jan&#x27;</span>].<span class="title function_">map</span>((name): <span class="function"><span class="params">Person</span> =&gt;</span> (&#123;name&#125;));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people); <span class="comment">// 输出：[&#123;name: &#x27;alice&#x27;&#125;, &#123;name: &#x27;bob&#x27;&#125;, &#123;name: &#x27;jan&#x27;&#125;]</span></span><br></pre></td></tr></table></figure><p>在上面的示例中：</p><ul><li><code>Person</code>是一个类型别名，代表一个对象，具有<code>name</code>属性的对象。</li><li>变量<code>people</code>是数组的<code>map()</code>方法的返回值。</li><li><code>map</code>方法的参数是一个箭头函数<code>(name): Person =&gt; (&#123;name&#125;)</code>：<ul><li>参数<code>name</code>的类型省略，TypeScript 从数组元素类型（string）推断为<code>name: string</code>。</li><li>返回值类型 : Person 指定返回<code>&#123; name: string &#125;</code>。</li><li><code>(&#123;name&#125;)</code>使用圆括号返回对象字面量，等价于<code>&#123; name: name &#125;</code>。</li></ul></li><li>变量<code>people</code>的类型被推断为<code>Person[]</code>（即<code>&#123; name: string &#125;[]</code>）。</li></ul><br><h1 id="Reference">6. Reference</h1><ul><li><a target="_blank" rel="noopener" href="https://wangdoc.com/typescript/">TypeScript 教程</a></li><li><a target="_blank" rel="noopener" href="https://ts.xcatliu.com/">TypeScript 入门教程</a></li></ul><link rel="stylesheet" href="/css/folder.css" type="text/css"><script src="/js/folder.js" type="text/javascript" async></script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></div><div id="btn-catalog" class="btn-catalog"><i class="iconfont icon-catalog"></i></div><div class="post-catalog hidden" id="catalog"><div class="title">目录</div><div class="catalog-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Cheat-Sheet"><span class="toc-text">1. Cheat Sheet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E3%80%81%E6%8A%BD%E8%B1%A1%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-text">2. 封装、抽象、继承和多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">2.1. 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-text">2.2. 抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">2.3. 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">2.4. 多态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">3. 基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">3.1. 类型声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-text">3.2. 类型推断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-text">3.3. 编译</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">4. 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.1. 三种特殊类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#any"><span class="toc-text">4.1.1. any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unknown"><span class="toc-text">4.1.2. unknown</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F"><span class="toc-text">4.1.2.1. 类型缩小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never"><span class="toc-text">4.1.3. never</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-text">4.2. 类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.2.1. 基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.2.2. 包装对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">4.2.2.1. 包装对象与字面量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E4%B8%8E-object"><span class="toc-text">4.2.3. Object 与 object</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.2.3.1. Object类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object-%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.2.3.2. object 类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.2.4. 值类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">4.3. 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-text">4.4. 元组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">5. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">5.1. 函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">5.2. 箭头函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-text">6. Reference</span></a></li></ol></div></div><script src="/js/catalog.js"></script><div class="comments-container"></div></div><div class="footer"><div class="social"><ul><li><a title="github" target="_blank" rel="noopener" href="https://github.com/Simba-cheng"><i class="iconfont icon-github"></i></a></li><li><a title="rss" href="/atom.xml"><i class="iconfont icon-rss"></i></a></li></ul></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a></div><div class="footer-views">本站总访问量<span id="busuanzi_value_site_pv"></span>次 本文总阅读量<span id="busuanzi_value_page_pv"></span>次 本站访客数<span id="busuanzi_value_site_uv"></span>人</div></div></div><div class="tools-bar"><div class="back-to-top tools-bar-item hidden"><a href="javascript: void(0)"><i class="iconfont icon-chevronup"></i></a></div><script src="/js/backtotop.js"></script><div class="search-icon tools-bar-item" id="search-icon"><a href="javascript: void(0)"><i class="iconfont icon-search"></i></a></div><div class="search-overlay hidden"><div class="search-content" tabindex="0"><div class="search-title"><span class="search-icon-input"><a href="javascript: void(0)"><i class="iconfont icon-search"></i> </a></span><input type="text" class="search-input" id="search-input" placeholder="搜索..."> <span class="search-close-icon" id="search-close-icon"><a href="javascript: void(0)"><i class="iconfont icon-close"></i></a></span></div><div class="search-result" id="search-result"></div></div></div><script type="text/javascript">var inputArea=document.querySelector("#search-input"),searchOverlayArea=document.querySelector(".search-overlay");function openOrHideSearchContent(){searchOverlayArea.classList.contains("hidden")?(searchOverlayArea.classList.remove("hidden"),document.body.classList.add("hidden")):(searchOverlayArea.classList.add("hidden"),document.body.classList.remove("hidden"))}function blurSearchContent(e){e.target===searchOverlayArea&&openOrHideSearchContent()}inputArea.onclick=function(){getSearchFile(),this.onclick=null},inputArea.onkeydown=function(){if(13==event.keyCode)return!1},document.querySelector("#search-icon").addEventListener("click",openOrHideSearchContent,!1),document.querySelector("#search-close-icon").addEventListener("click",openOrHideSearchContent,!1),searchOverlayArea.addEventListener("click",blurSearchContent,!1);var searchFunc=function(e,t,n){"use strict";var r=document.getElementById(t),a=document.getElementById(n);a.innerHTML="<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>",$.ajax({url:e,dataType:"xml",success:function(e){var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get();a.innerHTML="",r.addEventListener("input",function(){var u='<ul class="search-result-list">',h=this.value.trim().toLowerCase().split(/[\s\-]+/);if(a.innerHTML="",!(this.value.trim().length<=0)){if(t.forEach(function(e){var n,r,a=!0,t=(e.title&&""!==e.title.trim()||(e.title="Untitled"),e.title.trim()),c=t.toLowerCase(),s=e.content.trim().replace(/<[^>]+>/g,""),i=s.toLowerCase(),e=e.url,l=-1,o=-1;""!==i?h.forEach(function(e,t){n=c.indexOf(e),l=i.indexOf(e),n<0&&l<0?a=!1:(l<0&&(l=0),0==t&&(o=l))}):a=!1,a&&(u+="<li><a href='"+e+"' class='search-result-title'>"+t+"</a>",0<=o&&(e=o+80,(e=0==(t=(t=o-20)<0?0:t)?100:e)>s.length&&(e=s.length),r=s.substr(t,e),h.forEach(function(e){var t=new RegExp(e,"gi");r=r.replace(t,'<span class="search-keyword">'+e+"</span>")}),u+='<p class="search-result-abstract">'+r+"...</p>"),u+="</li>")}),-1===(u+="</ul>").indexOf("<li>"))return a.innerHTML="<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";a.innerHTML=u}})},error:function(e,t,n){a.innerHTML="",404===e.status?a.innerHTML="<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>":a.innerHTML="<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>"}}),$(document).on("click","#search-close-icon",function(){$("#search-input").val(""),$("#search-result").html("")})},getSearchFile=function(){searchFunc("/search.xml","search-input","search-result")}</script><div class="tools-bar-item theme-icon" id="switch-color-scheme"><a href="javascript: void(0)"><i id="theme-icon" class="iconfont icon-moon"></i></a></div><script src="/js/colorscheme.js"></script><div class="share-icon tools-bar-item"><a href="javascript: void(0)" id="share-icon"><i class="iconfont iconshare"></i></a><div class="share-content hidden"><a class="share-item" href="https://twitter.com/intent/tweet?text=' + %F0%9F%94%96%20TypeScript-Cheat-Sheet + '&url=' + https%3A%2F%2Fsimba-cheng.github.io%2Fposts%2F64106.html + '" target="_blank" title="Twitter"><i class="iconfont icon-twitter"></i> </a><a class="share-item" href="https://www.facebook.com/sharer.php?u=https://simba-cheng.github.io/posts/64106.html" target="_blank" title="Facebook"><i class="iconfont icon-facebooksquare"></i></a></div></div><script src="/js/shares.js"></script></div></div><script src="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/js/index.js"></script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a=c[o],i=function(){c=c.filter(function(t){return a!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(a)};(t=a).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,n=t.getAttribute("data-original"),e.onload=function(){t.src=n,t.removeAttribute("data-original"),i()},t.src!==n&&(e.src=n))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this)</script><script src="/js/markmap.js"></script></body></html>
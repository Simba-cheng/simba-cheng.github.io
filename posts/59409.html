<!DOCTYPE html><html lang="zh-CN" color-mode="light"><head><link href="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/css/index.css" rel="stylesheet"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><script defer src="/_vercel/insights/script.js"></script><script defer src="/_vercel/speed-insights/script.js"></script><meta name="author" content="yxcheng"><title>LOCK 指令 | 躺着好舒服</title><link rel="apple-touch-icon" href="/images/favicon.png"><link rel="icon" href="/images/favicon.png"><link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css"><link rel="stylesheet" href="/css/figcaption/mac-block.css"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3163875893588085" crossorigin="anonymous"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><link href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" rel="stylesheet"><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/fancybox.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-WB9L6JQGS1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-WB9L6JQGS1")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var html=document.documentElement;const colorMode=localStorage.getItem("color-mode");colorMode&&document.documentElement.setAttribute("color-mode",colorMode)</script><link rel="stylesheet" href="/css/collapse-code.css"><script src="/js/collapse-code.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="躺着好舒服" type="application/atom+xml"></head><body><div id="app"><div class="header"><div class="avatar"><a href="/"><img no-lazy src="/images/avatar.png" alt=""></a><div class="nickname"><a href="/">躺着好舒服</a></div></div><div class="navbar"><ul><li class="nav-item" data-path="/"><a href="/">首页</a></li><li class="nav-item" data-path="/tags/"><a href="/tags/">标签</a></li><li class="nav-item" data-path="/categories/"><a href="/categories/">分类</a></li><li class="nav-item" data-path="/archives/"><a href="/archives/">归档</a></li><li class="nav-item" data-path="/notes/"><a href="/notes/">Notes</a></li><li class="nav-item" data-path="/adventure/"><a href="/adventure/">冒险乐园</a></li></ul></div></div><script src="/js/activeNav.js"></script><div class="flex-container"><script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.10/dist/clipboard.min.js"></script><script src="/js/codeCopy.js"></script><div class="container post-details" id="post-details"><div class="post-content"><div class="post-title">LOCK 指令</div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime mr-10" title="更新时间"></i> 创建时间:2022-06-25 22:32:12&nbsp; 更新时间:2025-04-21 09:14:59 &nbsp;&nbsp; </span><span><span><i class="iconfont icon-edit"></i> 3.9k 字 </span>&nbsp;&nbsp; </span><span class="post-tags"><i class="iconfont icon-tags mr-10" title="标签"></i> <span class="span--tag mr-8"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" title="计算机基础">#计算机基础&nbsp;</a></span></span></div><div class="markdown-body"><center><a style="font-style:italic" href="javascript:window.location='https://simba--cheng-cn.translate.goog/' + window.location.pathname + '?_x_tr_sl=zh-CN&amp;_x_tr_tl=en&amp;_x_tr_hl=zh-CN&amp;_x_tr_pto=wapp';">This post is also available in English and alternative languages.</a></center><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>阅读《Intel® 64 and IA-32 Architectures Software Developer’s Manual》相关文档，了解 <code>lock</code> 指令相关内容。</p><p><code>lock</code> 指令的介绍、描述，散落在文档的各个章节，下面按照卷、章节归纳整理。</p><p>《Intel® 64 and IA-32 Architectures Software Developer’s Manual》分卷说明：</p><ul><li><p>Volume 1:Basic Architecture（第一卷）：基础架构</p></li><li><p>Volume 2 (2A, 2B, 2C &amp; 2D):Instruction Set（第二卷）：指令集参考</p></li><li><p>Volume 3 (3A, 3B, 3C &amp; 3D):System Programming Guide（第三卷）：系统编程指南</p></li></ul><blockquote><p>更多细节请详阅文档，本文摘录会删减部分无关内容。</p><p><strong>注意：受能力水平限制，以下翻译、理解内容不完全准确，欢迎讨论。</strong></p></blockquote><br><h1 id="结论先行">1. 结论先行</h1><p>LOCK前缀指令，早期的处理器会触发总线锁；后期更新的处理器，优先使用缓存锁（CPU高速缓存锁），无法满足的情况下再使用总线锁。</p><p>多个Core的缓存中共同缓存了某内存地址的数据；如果某个Core修改数据（读-修改-写）时使用了LOCK前缀指令，那么LOCK指令结合MESI协议会将其他Core的缓存中对应数据状态置为失效，同时将修改完的数据回写到主内存中，并且保证指令执行的原子性。</p><br><h1 id="术语约定">2. 术语约定</h1><ul><li><p>LOCK (prefix) &#x3D; LOCK前缀指令</p></li><li><p>LOCK# signal &#x3D; LOCK#信号</p></li><li><p>处理器 &#x3D; core &#x3D; 多核CPU中的一个核心</p></li><li><p>缓存锁 &#x3D; 高速缓存锁 &#x3D; CPU高速缓存锁</p></li><li><p>asserted</p><p>结合资料，<font color="#FF4500">asserted</font>要理解为<strong>发送信号</strong>。</p><ul><li>早期通过锁总线保证指令的原子性，<font color="#FF4500">asserted</font>理解为’向总线发送信号’。</li><li>后来通过锁缓存结合缓存一致性保证指令的原子性，<font color="#FF4500">asserted</font>理解为’向缓存控制器发信号’。</li></ul><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/reliveIT/article/details/90038750">Intel#LOCK前缀指令</a></p></blockquote></li></ul><br><h1 id="文档描述">3. 文档描述</h1><h2 id="Volume-1-Basic-Architecture">3.1. Volume 1:Basic Architecture</h2><h3 id="Chapter-5-Instruction-Set-Summary">3.1.1. Chapter 5 Instruction Set Summary</h3><blockquote><p>位置： &lt;5.20 System Instructions&gt;</p></blockquote><p>LOCK（前缀） - 执行对内存的原子访问（可应用于提供存储器源&#x2F;目标访问的多个通用指令）</p><blockquote><p>LOCK (prefix) - Perform atomic access to memory (can be applied to a number of general purpose instructions that provide memory source&#x2F;destination access).</p></blockquote><br><h3 id="Chapter-7-Programming-With-General-Purpose-Instructions">3.1.2. Chapter 7 Programming With General-Purpose Instructions</h3><blockquote><p>位置：&lt;7.3 Summary of GP Instructions&gt; - &lt;7.3.1 Data Transfer Instructions&gt; - &lt;7.3.1.2 Exchange Instructions&gt;</p></blockquote><p><b><font color="#FF4500">CMPXCHG（比较与交换）</font></b> 和 <strong>CMPXCHG8B(比较与交换 8bytes)</strong> 指令在多处理器系统中用于同步操作。</p><p><code>CMPXCHG</code> 指令需要三个操作数：寄存器中的一个源操作数、EAX寄存器中的另一个源操作数和目标操作数。如果目标操作数和EAX寄存器中包含的值相等，则目标操作数将替换为另一个源操作数的值(不在EAX寄存器中的值)。否则，目标操作数的原始值被加载到EAX寄存器中。EFLAGS寄存器中的状态标志反映了从EAX寄存器中的值减去目标操作数所获得的结果。</p><p><code>CMPXCHG</code> 指令通常用于测试和修改信号量；它检查信号量是否空闲。</p><p>如果信号量是空闲的，则将其标记为已分配；如果信号量不是空闲的，将获取到当前所有者的ID；这一切都是在一个不间断的操作中完成的；</p><p>在单处理器系统中，<code>CMPXCHG</code> 指令在执行多条指令测试和修改信号量之前，不需要切换到保护级别0(禁用中断)。</p><p>对于多处理器系统，可以将 <code>CMPXCHG</code> 与 <code>lock</code> 前缀结合起来，以<b><font color="#FF4500">原子方式执行比较和交换</font></b>操作。</p><blockquote><p>The CMPXCHG (compare and exchange) and CMPXCHG8B (compare and exchange 8 bytes) instructions are used to synchronize operations in systems that use multiple processors.</p><p>The CMPXCHG instruction requires three operands: a source operand in a register, another source operand in the EAX register, and a destination operand. If the values contained in the destination operand and the EAX register are equal, the destination operand is replaced with the value of the other source operand (the value not in the EAX register). Otherwise, the original value of the destination operand is loaded in the EAX register. The status flags in the EFLAGS register reflect the result that would have been obtained by subtracting the destination operand from the value in the EAX register.</p><hr><p>The CMPXCHG instruction is commonly used for testing and modifying semaphores. It checks to see if a semaphore is free.</p><p>If the semaphore is free, it is marked allocated; otherwise it gets the ID of the current owner. This is all done in one uninterruptible operation.</p><p>In a single-processor system, the CMPXCHG instruction eliminates the need to switch to protection level 0 (to disable interrupts) before executing multiple instructions to test and modify a semaphore.</p><p>For multiple processor systems, CMPXCHG can be combined with the LOCK prefix to perform the compare and exchange operation atomically.</p></blockquote><br><h2 id="Volume-2-Instruction-Set-Reference">3.2. Volume 2 : Instruction Set Reference</h2><h3 id="Chapter-2-Instruction-Format">3.2.1. Chapter 2 Instruction Format</h3><blockquote><p>位置：&lt;2.1.1 Instruction Prefixes&gt;</p></blockquote><p>LOCK前缀指令强制执行一个操作，确保在多处理器环境中独占共享内存。</p><blockquote><p>The LOCK prefix (F0H) forces an operation that ensures exclusive use of shared memory in a multiprocessor environment. See “LOCK—Assert LOCK# Signal Prefix” in Chapter 3, “Instruction Set Reference, A-L,” for a description of this prefix.</p></blockquote><br><h3 id="Chapter-3-Instruction-Set-Reference">3.2.2. Chapter 3 Instruction Set Reference</h3><blockquote><p>位置：&lt;3.2 INSTRUCTIONS&gt; - &lt;LOCK—Assert LOCK# Signal Prefix&gt;</p></blockquote><p>执行指令时，LOCK前缀会向处理器发送一个LOCK#信号，即：将指令转换为原子指令；在多处理器环境中，发送的LOCK#信号确保处理器独占任何共享内存。</p><p>LOCK前缀通常与BTS指令一起用于对共享内存环境中的内存位置执行读-修改-写操作；LOCK前缀的完整性不受内存字段对齐的影响；内存锁定会观察到任意错位的字段。</p><p>该指令的操作在非64位模式和64位模式下是相同的。</p><p>从P6系列处理器开始，当LOCK作为指令的前缀时，并且要访问的内存区被缓存在处理器内部时，不会发送LOCK#信号；相反，只有处理器的缓存被锁定时，才会发送LOCK#信号。</p><blockquote><p>Causes the processor’s LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal ensures that the processor has exclusive use of any shared memory while the signal is asserted.</p><p>The LOCK prefix is typically used with the BTS instruction to perform a read-modify-write operation on a memory location in shared memory environment.The integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed for arbitrarily misaligned fields.<br>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p><hr><p>Beginning with the P6 family processors, when the LOCK prefix is prefixed to an instruction and the memory area being accessed is cached internally in the processor, the LOCK# signal is generally not asserted. Instead, only the processor’s cache is locked. Here, the processor’s cache coherency mechanism ensures that the operation is carried out atomically with regards to memory.</p></blockquote><br><h2 id="Volume-3-System-Programming-Guide">3.3. Volume 3 : System Programming Guide</h2><h3 id="Chapter-2-System-Architecture-Overview">3.3.1. Chapter 2 System Architecture Overview</h3><blockquote><p>位置：&lt;2.8 System Instruction Summary&gt; - &lt;2.8.5 Controlling the Processor&gt;</p></blockquote><p>在修改内存操作时，使用LOCK前缀去调用加锁的读-修改-写操作，这种机制用于多处理器系统中处理器之间进行可靠的通讯，具体描述如下：</p><ol><li>在Pentium和早期的IA-32处理器中，LOCK前缀会使处理器执行当前指令时产生一个LOCK#信号，这会显示的触发总线锁。</li><li>在Pentium4、Inter Xeon和P6系列处理器中，加锁操作是由高速缓存锁或总线锁来处理；<ol><li>如果内存访问（个人理解：内存中的某数据）有且只在一个Core的高速缓存中，那么就会调用高速缓存锁；而系统总线和系统内存中的实际区域内不会被锁定。其他Pentium4、Intel Xeon或者P6系列处理器在总线上回写所有已修改的数据并使它们的高速缓存失效，以保证系统内存的一致性。</li><li>如果内存访问没有高速缓存 并且&#x2F;或 它跨越了高速缓存行的边界，那么这个处理器就会产生LOCK#信号，并在锁定操作期间不会响应总线控制请求。</li></ol></li></ol><blockquote><p>The LOCK prefix invokes a locked (atomic) read-modify-write operation when modifying a memory operand. This mechanism is used to allow reliable communications between processors in multiprocessor systems, as described below:</p><ul><li>In the Pentium processor and earlier IA-32 processors, the LOCK prefix causes the processor to assert the LOCK# signal during the instruction. This always causes an explicit bus lock to occur.</li><li>In the Pentium 4, Intel Xeon, and P6 family processors, the locking operation is handled with either a cache lock or bus lock. If a memory access is cacheable and affects only a single cache line, a cache lock is invoked and the system bus and the actual memory location in system memory are not locked during the operation. Here, other Pentium 4, Intel Xeon, or P6 family processors on the bus write-back any modified data and invalidate their caches as necessary to maintain system memory coherency. If the memory access is not cacheable and&#x2F;or it crosses a cache line boundary, the processor’s LOCK# signal is asserted and the processor does not respond to requests for bus control during the locked operation.</li></ul></blockquote><br><h3 id="Chapter-8-Multiple-Processor-Management">3.3.2. Chapter 8 Multiple-Processor Management</h3><h4 id="8-1-LOCKED-ATOMIC-OPERATIONS">3.3.2.1. 8.1 LOCKED ATOMIC OPERATIONS</h4><p>32位IA-32处理器支持对系统内存中的某个区域进行加锁的原子操作。这些操作常用来管理共享的数据结构（如信号量、段描述符、系统段或页表），其中两个或多个处理器可能同时会修改这些数据结构中的同一数据域或标志。处理器使用三个相互依赖的机制来实现加锁的原子操作：</p><ul><li>保证原子操作</li><li>总线加锁，使用LOCK#信号和LOCK指令前缀</li><li>高速缓存相关性协议，确保对高速缓存中的数据结构执行原子操作（高速缓存锁）。这种机制存在于Pentium4、Intel Xeon和P6系列处理器中</li></ul><blockquote><p>The 32-bit IA-32 processors support locked atomic operations on locations in system memory. These operations are typically used to manage shared data structures (such as semaphores, segment descriptors, system segments, or page tables) in which two or more processors may try simultaneously to modify the same field or flag. The processor uses three interdependent mechanisms for carrying out locked atomic operations:</p><p>• Guaranteed atomic operations.<br>• Bus locking, using the LOCK# signal and the LOCK instruction prefix.<br>• Cache coherency protocols that ensure that atomic operations can be carried out on cached data structures (cache lock); this mechanism is present in the Pentium 4, Intel Xeon, and P6 family processors.</p></blockquote><br><h5 id="8-1-2-Bus-Locking">3.3.2.1.1. 8.1.2 Bus Locking</h5><p>Intel64和IA-32处理器提供了一个LOCK#信号，会在某些关键内存操作期间被自动激活，去锁定系统总线。</p><p>当这个输出信号发出的时候，来自其他处理器或总线代理的控制请求将被阻塞。软件能够通过预先在指令前添加LOCK前缀来指定需要LOCK语义的其它场合。</p><p>在Intel386、Intel486、Pentium处理器中，明确地对指令加锁会导致LOCK#信号的产生。由硬件设计人员来保证系统硬件中LOCK#信号的可用性，以控制处理器间的内存访问。</p><p>对于Pentinum4、Intel Xeon以及P6系列处理器，如果被访问的内存区域是在处理器内部进行高速缓存的，那么通常不发出LOCK#信号；相反，加锁只应用于处理器的高速缓存。</p><blockquote><p>Intel 64 and IA-32 processors provide a LOCK# signal that is asserted automatically during certain critical memory operations to lock the system bus or equivalent link.</p><p>While this output signal is asserted, requests from other processors or bus agents for control of the bus are blocked. Software can specify other occasions when the LOCK semantics are to be followed by prepending the LOCK prefix to an instruction.</p><p>In the case of the Intel386, Intel486, and Pentium processors, explicitly locked instructions will result in the assertion of the LOCK# signal. It is the responsibility of the hardware designer to make the LOCK# signal available in system hardware to control memory accesses among processors.</p><p>For the P6 and more recent processor families, if the memory area being accessed is cached internally in the processor, the LOCK# signal is generally not asserted; instead, locking is only applied to the processor’s caches (see Section 8.1.4, “Effects of a LOCK Operation on Internal Processor Caches”).</p></blockquote><br><h6 id="8-1-2-2-Software-Controlled-Bus-Locking">3.3.2.1.1.1. 8.1.2.2 Software Controlled Bus Locking</h6><p>为显式地强制执行LOCK语义，软件可以在下列指令修改内存区域时同时使用LOCK前缀。</p><ol><li>bit测试和修改指令（BTS、BTR、BTC）</li><li>交换指令（XADD、CMPXCHG、CMPXCHG8B）</li><li>XCHG指令会自动添加LOCK前缀</li><li>单操作数的算数和逻辑指令：INC、DEC、NOT、NEG</li><li>双操作数的算数和逻辑指令：ADD、ADC、SUB、SBB、AND、OR、XOR</li></ol><p>一个加锁的指令会保证对目标操作数所在的内存区域加锁，但是系统可能会将锁定区域解释得稍大一些。<br>软件应该使用相同的地址和操作数长度来访问信号量（用作处理器之间发送信号的共享内存）。例如，如果一个处理器使用一个字来访问信号量，其它处理器就不应该使用一个字节来访问这个信号量。</p><p>总线锁的完整性不受内存区域对齐的影响。加锁语义会一直持续，以满足更新整个操作数所需的总线周期个数。但是，建议加锁访问应该对齐在它们的自然边界上，以提升系统性能：</p><ol><li>任何8位访问的边界（加锁或不加锁）</li><li>锁定的字访问的16位边界</li><li>锁定的双字访问的32位边界</li><li>锁定的四字访问的64位边界</li></ol><p>对所有其它的内存操作和所有可见的外部事件来说，加锁的操作都是原子的。所有取指令和页表操作能够越过加锁的指令。加锁的指令可用于同步一个处理器写数据而另一个处理器读数据的操作。</p><blockquote><p>To explicitly force the LOCK semantics, software can use the LOCK prefix with the following instructions when they are used to modify a memory location.</p><ol><li>The bit test and modify instructions (BTS, BTR, and BTC).</li><li>The exchange instructions (XADD, CMPXCHG, and CMPXCHG8B).</li><li>The LOCK prefix is automatically assumed for XCHG instruction.</li><li>The following single-operand arithmetic and logical instructions: INC, DEC, NOT, and NEG.</li><li>The following two-operand arithmetic and logical instructions: ADD, ADC, SUB, SBB, AND, OR, and XOR.</li></ol><hr><p>A locked instruction is guaranteed to lock only the area of memory defined by the destination operand, but may be interpreted by the system as a lock for a larger memory area.</p><p>Software should access semaphores (shared memory used for signalling between multiple processors) using identical addresses and operand lengths. For example, if one processor accesses a semaphore using a word access, other processors should not access the semaphore using a byte access.</p><hr><p>The integrity of a bus lock is not affected by the alignment of the memory field. The LOCK semantics are followed for as many bus cycles as necessary to update the entire operand. However, it is recommend that locked accesses be aligned on their natural boundaries for better system performance:</p><ol><li>Any boundary for an 8-bit access (locked or otherwise).</li><li>16-bit boundary for locked word accesses.</li><li>32-bit boundary for locked doubleword accesses.</li><li>64-bit boundary for locked quadword accesses.</li></ol><p>Locked operations are atomic with respect to all other memory operations and all externally visible events. Only instruction fetch and page table accesses can pass locked instructions. Locked instructions can be used to synchronize data written by one processor and read by another processor.</p></blockquote><br><h5 id="8-1-4-Effects-of-a-LOCK-Operation-on-Internal-Processor-Caches">3.3.2.1.2. 8.1.4 Effects of a LOCK Operation on Internal Processor Caches</h5><p>对于 Intel486 和 Pentium 处理器，在锁定操作期间，即使被锁定的内存区域在高速缓存中，也会发送LOCK#信号去锁定总线。</p><p>P6及更新的处理器系列，如果在锁定操作过程中锁定内存的区域是在处理器缓存中的，若此时发生修改操作，不会总是发送LOCK#信号去锁定总线。相反会结合缓存一致性协议，保证操作以原子方式执行。</p><p>此操作被称为<code>cache locking</code>（缓存锁定）；缓存一致性协议会自动防止两个或多个缓存了相同内存区域的处理器同时修改该区域的数据。</p><blockquote><p>For the Intel486 and Pentium processors, the LOCK# signal is always asserted on the bus during a LOCK operation,even if the area of memory being locked is cached in the processor.</p><p>For the P6 and more recent processor families, if the area of memory being locked during a LOCK operation is cached in the processor that is performing the LOCK operation as write-back memory and is completely contained in a cache line, the processor may not assert the LOCK# signal on the bus. Instead, it will modify the memory location internally and allow it’s cache coherency mechanism to ensure that the operation is carried out atomically.</p><p>This operation is called “cache locking.” The cache coherency mechanism automatically prevents two or more processors that have cached the same area of memory from simultaneously modifying data in that area.</p></blockquote><br><h1 id="Reference">4. Reference</h1><ul><li>《Intel® 64 and IA-32 Architectures Software Developer’s Manual》</li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xrq730/p/7048693.html">就是要你懂Java中volatile关键字实现原理#lock指令做了什么</a></li></ul><br><link rel="stylesheet" href="/css/folder.css" type="text/css"><script src="/js/folder.js" type="text/javascript" async></script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></div><div id="btn-catalog" class="btn-catalog"><i class="iconfont icon-catalog"></i></div><div class="post-catalog hidden" id="catalog"><div class="title">目录</div><div class="catalog-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E5%85%88%E8%A1%8C"><span class="toc-text">1. 结论先行</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD%E7%BA%A6%E5%AE%9A"><span class="toc-text">2. 术语约定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%8F%8F%E8%BF%B0"><span class="toc-text">3. 文档描述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Volume-1-Basic-Architecture"><span class="toc-text">3.1. Volume 1:Basic Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-5-Instruction-Set-Summary"><span class="toc-text">3.1.1. Chapter 5 Instruction Set Summary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-7-Programming-With-General-Purpose-Instructions"><span class="toc-text">3.1.2. Chapter 7 Programming With General-Purpose Instructions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volume-2-Instruction-Set-Reference"><span class="toc-text">3.2. Volume 2 : Instruction Set Reference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-2-Instruction-Format"><span class="toc-text">3.2.1. Chapter 2 Instruction Format</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-3-Instruction-Set-Reference"><span class="toc-text">3.2.2. Chapter 3 Instruction Set Reference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volume-3-System-Programming-Guide"><span class="toc-text">3.3. Volume 3 : System Programming Guide</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-2-System-Architecture-Overview"><span class="toc-text">3.3.1. Chapter 2 System Architecture Overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter-8-Multiple-Processor-Management"><span class="toc-text">3.3.2. Chapter 8 Multiple-Processor Management</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-LOCKED-ATOMIC-OPERATIONS"><span class="toc-text">3.3.2.1. 8.1 LOCKED ATOMIC OPERATIONS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-2-Bus-Locking"><span class="toc-text">3.3.2.1.1. 8.1.2 Bus Locking</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#8-1-2-2-Software-Controlled-Bus-Locking"><span class="toc-text">3.3.2.1.1.1. 8.1.2.2 Software Controlled Bus Locking</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-4-Effects-of-a-LOCK-Operation-on-Internal-Processor-Caches"><span class="toc-text">3.3.2.1.2. 8.1.4 Effects of a LOCK Operation on Internal Processor Caches</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-text">4. Reference</span></a></li></ol></div></div><script src="/js/catalog.js"></script><div class="comments-container"></div></div><div class="footer"><div class="social"><ul><li><a title="github" target="_blank" rel="noopener" href="https://github.com/Simba-cheng"><i class="iconfont icon-github"></i></a></li><li><a title="rss" href="/atom.xml"><i class="iconfont icon-rss"></i></a></li></ul></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a></div><div class="footer-views">本站总访问量<span id="busuanzi_value_site_pv"></span>次 本文总阅读量<span id="busuanzi_value_page_pv"></span>次 本站访客数<span id="busuanzi_value_site_uv"></span>人</div></div></div><div class="tools-bar"><div class="back-to-top tools-bar-item hidden"><a href="javascript: void(0)"><i class="iconfont icon-chevronup"></i></a></div><script src="/js/backtotop.js"></script><div class="search-icon tools-bar-item" id="search-icon"><a href="javascript: void(0)"><i class="iconfont icon-search"></i></a></div><div class="search-overlay hidden"><div class="search-content" tabindex="0"><div class="search-title"><span class="search-icon-input"><a href="javascript: void(0)"><i class="iconfont icon-search"></i> </a></span><input type="text" class="search-input" id="search-input" placeholder="搜索..."> <span class="search-close-icon" id="search-close-icon"><a href="javascript: void(0)"><i class="iconfont icon-close"></i></a></span></div><div class="search-result" id="search-result"></div></div></div><script type="text/javascript">var inputArea=document.querySelector("#search-input"),searchOverlayArea=document.querySelector(".search-overlay");function openOrHideSearchContent(){searchOverlayArea.classList.contains("hidden")?(searchOverlayArea.classList.remove("hidden"),document.body.classList.add("hidden")):(searchOverlayArea.classList.add("hidden"),document.body.classList.remove("hidden"))}function blurSearchContent(e){e.target===searchOverlayArea&&openOrHideSearchContent()}inputArea.onclick=function(){getSearchFile(),this.onclick=null},inputArea.onkeydown=function(){if(13==event.keyCode)return!1},document.querySelector("#search-icon").addEventListener("click",openOrHideSearchContent,!1),document.querySelector("#search-close-icon").addEventListener("click",openOrHideSearchContent,!1),searchOverlayArea.addEventListener("click",blurSearchContent,!1);var searchFunc=function(e,t,n){"use strict";var r=document.getElementById(t),a=document.getElementById(n);a.innerHTML="<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>",$.ajax({url:e,dataType:"xml",success:function(e){var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get();a.innerHTML="",r.addEventListener("input",function(){var u='<ul class="search-result-list">',h=this.value.trim().toLowerCase().split(/[\s\-]+/);if(a.innerHTML="",!(this.value.trim().length<=0)){if(t.forEach(function(e){var n,r,a=!0,t=(e.title&&""!==e.title.trim()||(e.title="Untitled"),e.title.trim()),c=t.toLowerCase(),s=e.content.trim().replace(/<[^>]+>/g,""),i=s.toLowerCase(),e=e.url,l=-1,o=-1;""!==i?h.forEach(function(e,t){n=c.indexOf(e),l=i.indexOf(e),n<0&&l<0?a=!1:(l<0&&(l=0),0==t&&(o=l))}):a=!1,a&&(u+="<li><a href='"+e+"' class='search-result-title'>"+t+"</a>",0<=o&&(e=o+80,(e=0==(t=(t=o-20)<0?0:t)?100:e)>s.length&&(e=s.length),r=s.substr(t,e),h.forEach(function(e){var t=new RegExp(e,"gi");r=r.replace(t,'<span class="search-keyword">'+e+"</span>")}),u+='<p class="search-result-abstract">'+r+"...</p>"),u+="</li>")}),-1===(u+="</ul>").indexOf("<li>"))return a.innerHTML="<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";a.innerHTML=u}})},error:function(e,t,n){a.innerHTML="",404===e.status?a.innerHTML="<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>":a.innerHTML="<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>"}}),$(document).on("click","#search-close-icon",function(){$("#search-input").val(""),$("#search-result").html("")})},getSearchFile=function(){searchFunc("/search.xml","search-input","search-result")}</script><div class="tools-bar-item theme-icon" id="switch-color-scheme"><a href="javascript: void(0)"><i id="theme-icon" class="iconfont icon-moon"></i></a></div><script src="/js/colorscheme.js"></script><div class="share-icon tools-bar-item"><a href="javascript: void(0)" id="share-icon"><i class="iconfont iconshare"></i></a><div class="share-content hidden"><a class="share-item" href="https://twitter.com/intent/tweet?text=' + LOCK%20%E6%8C%87%E4%BB%A4 + '&url=' + https%3A%2F%2Fsimba-cheng.github.io%2Fposts%2F59409.html + '" target="_blank" title="Twitter"><i class="iconfont icon-twitter"></i> </a><a class="share-item" href="https://www.facebook.com/sharer.php?u=https://simba-cheng.github.io/posts/59409.html" target="_blank" title="Facebook"><i class="iconfont icon-facebooksquare"></i></a></div></div><script src="/js/shares.js"></script></div></div><script src="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/js/index.js"></script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a=c[o],i=function(){c=c.filter(function(t){return a!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(a)};(t=a).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,n=t.getAttribute("data-original"),e.onload=function(){t.src=n,t.removeAttribute("data-original"),i()},t.src!==n&&(e.src=n))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this)</script><script src="/js/markmap.js"></script></body></html>
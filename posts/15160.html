<!DOCTYPE html><html lang="zh-CN" color-mode="light"><head><link href="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/css/index.css" rel="stylesheet"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><script defer src="/_vercel/insights/script.js"></script><script defer src="/_vercel/speed-insights/script.js"></script><meta name="author" content="yxcheng"><title>Netty_NioEventLoop创建 | 躺着好舒服</title><link rel="apple-touch-icon" href="/images/favicon.png"><link rel="icon" href="/images/favicon.png"><link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css"><link rel="stylesheet" href="/css/figcaption/mac-block.css"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3163875893588085" crossorigin="anonymous"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><link href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" rel="stylesheet"><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/fancybox.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-WB9L6JQGS1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-WB9L6JQGS1")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var html=document.documentElement;const colorMode=localStorage.getItem("color-mode");colorMode&&document.documentElement.setAttribute("color-mode",colorMode)</script><link rel="stylesheet" href="/css/collapse-code.css"><script src="/js/collapse-code.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="躺着好舒服" type="application/atom+xml"></head><body><div id="app"><div class="header"><div class="avatar"><a href="/"><img no-lazy src="/images/avatar.png" alt=""></a><div class="nickname"><a href="/">躺着好舒服</a></div></div><div class="navbar"><ul><li class="nav-item" data-path="/"><a href="/">首页</a></li><li class="nav-item" data-path="/tags/"><a href="/tags/">标签</a></li><li class="nav-item" data-path="/categories/"><a href="/categories/">分类</a></li><li class="nav-item" data-path="/archives/"><a href="/archives/">归档</a></li><li class="nav-item" data-path="/notes/"><a href="/notes/">Notes</a></li><li class="nav-item" data-path="/adventure/"><a href="/adventure/">冒险乐园</a></li></ul></div></div><script src="/js/activeNav.js"></script><div class="flex-container"><script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.10/dist/clipboard.min.js"></script><script src="/js/codeCopy.js"></script><div class="container post-details" id="post-details"><div class="post-content"><div class="post-title">Netty_NioEventLoop创建</div><div class="post-attach"><span class="post-pubtime"><i class="iconfont icon-updatetime mr-10" title="更新时间"></i> 创建时间:2022-11-30 14:48:44&nbsp; 更新时间:2025-04-21 09:14:58 &nbsp;&nbsp; </span><span><span><i class="iconfont icon-edit"></i> 4.8k 字 </span>&nbsp;&nbsp; </span><span class="post-tags"><i class="iconfont icon-tags mr-10" title="标签"></i> <span class="span--tag mr-8"><a href="/tags/netty/" title="netty">#netty&nbsp;</a></span></span></div><div class="markdown-body"><center><a style="font-style:italic" href="javascript:window.location='https://simba--cheng-cn.translate.goog/' + window.location.pathname + '?_x_tr_sl=zh-CN&amp;_x_tr_tl=en&amp;_x_tr_hl=zh-CN&amp;_x_tr_pto=wapp';">This post is also available in English and alternative languages.</a></center><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br><p>NioEventLoop 是 Netty 中的核心之一，通过阅读源码了解其 <u>创建 -&gt; 启动 -&gt; 运行</u> 的过程。</p><blockquote><ul><li><p><font color="#D2691E">网上很多资料都将创建的 NioEventLoopGroup 对象称之为: bossGroup(boss) 和 workGroup(work)，这里OP不会这么称呼，而是采用源码中变量的命名，即: <b>parentGroup</b>和 <b>childGroup</b></font>。</p></li><li><p><font color="#FF4500">文中图片较大，懒加载，请耐心等候</font>。</p></li><li><p>本文 Netty 源码解析基于 <b>4.1.86.Final</b> 版本。</p></li><li><p>另注: 受篇幅限制，NioEventLoop 源码拆分为 <a href="/posts/15160.html" title="Netty_NioEventLoop创建">Netty_NioEventLoop创建</a> 和 <a href="/posts/45721.html" title="Netty_NioEventLoop启动和运行">Netty_NioEventLoop启动和运行</a></p></li></ul></blockquote><br><h1 id="概览">1. 概览</h1><p>EventLoop 直译的话是 <strong>事件循环</strong> 的意思，在 Netty 中的作用也就是字面意思；<br>每当事件发生时，会将产生的事件放入事件队列当中，然后 EventLoop 会轮询从队列中取出事件执行或者将事件分发给相应的事件监听者执行。事件执行的方式通常分为<strong>立即执行、延后执行、定期执行</strong>几种。</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/15160/EventLoop通用运行模式.png" alt="EventLoop通用运行模式(图片来自网络)" style="zoom:50%"><p>Netty 的 EventLoop 是协同设计的一部分，它继承了JDK中 <code>java.util.concurrent</code> 相关并发类，用来执行线程相关操作，其次还继承了 <code>io.netty.channel</code> 包中的类，方便与 Channel 进行交互。</p><br><p>Netty 默认提供了如 <strong>NioEventLoop</strong> 等多种实现，<b><font color="#008B45">本篇围绕 NioEventLoop，其余的 EventLoop 实现不展开讨论</font></b>。</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/15160/EventLoop接口的实现.png" alt="EventLoop接口的实现" style="zoom:80%"><br><p>NioEventLoop 的生命周期分为三个过程：创建 -&gt; 启动 -&gt; 运行，本篇也会围绕这三个过程展开，在整个 Netty Reactor 工作架构中的位置大约如下红框所示(NioEventLoop 的创建包含在 NioEventLoopGroup 的创建过程中)。</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/15160/Netty Reactor 工作架构图.png" alt="Netty Reactor 工作架构图(图片来自网络)" style="zoom:42%"><br><h1 id="NioEventLoopGroup的构造函数">2. NioEventLoopGroup的构造函数</h1><p>NioEventLoop 的创建发生在创建 NioEventLoopGroup 时，即: <code>new NioEventLoopGroup()</code> 时，先跟随 NioEventLoopGroup 的构造函数，看下其中做了什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, (Executor) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// io.netty.channel.MultithreadEventLoopGroup</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// io.netty.util.concurrent.MultithreadEventExecutorGroup</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// io.netty.util.concurrent.MultithreadEventExecutorGroup</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>line: 2 -&gt; NioEventLoopGroup 默认构造函数中，<code>nThreads</code> 参数为0，后面将依据此参数确定创建 NioEventLoop 的数量。</p><p></p></li><li><p>line: 10 -&gt; <code>SelectorProvider.provider()</code> 方法用来创建 <code>java.nio.channels.spi.SelectorProvider</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.spi.SelectorProvider，相当于一个工厂类，提供了对 java.nio.channels.ServerSocketChannel、java.nio.channels.SocketChannel、java.nio.channels.Selector 等创建方法。
">[2]</span></a></sup>。</p><p></p></li><li><p>line: 15 -&gt; <code>DefaultSelectStrategyFactory.INSTANCE</code> ，NioEventLoop 最重要的事情之一就是：轮询注册其上 Channel 的 <u>I&#x2F;O就绪事件</u>，SelectStrategyFactory 用于指定轮询策略。</p><p></p></li><li><p>line: 25 -&gt; NioEventLoopGroup 父类 MultithreadEventLoopGroup 中的 <code>DEFAULT_EVENT_LOOP_THREADS</code> 属性决定了创建 NioEventLoop 的数量，暂时不表下面单独展开。</p><p></p></li><li><p>line: 30 -&gt; <code>DefaultEventExecutorChooserFactory.INSTANCE</code>，创建 chooser ，即选择器, 可以看做是负载均衡器, 用于从众多 NioEventLoop 中选取一个 NioEventLoop，暂时不表下面单独展开。</p><p></p></li><li><p>line: 34 -&gt; NioEventLoopGroup 父类 MultithreadEventExecutorGroup 的构造函数是 NioEventLoopGroup 构造函数调用链路中的核心逻辑所在，其中包含创建 NioEventLoop，下面单独展开。</p></li></ul><br><h2 id="确定创建NioEventLoop数量">2.1. 确定创建NioEventLoop数量</h2><p>在 NioEventLoopGroup 父类 MultithreadEventLoopGroup 的构造函数中确定了创建 NioEventLoop 的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.MultithreadEventLoopGroup</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">            <span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, Object... args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>line: 3 ~ line: 4 -&gt; 通过系统变量 <code>io.netty.eventLoopThreads</code> 获取数量，如没有指定，那默认就是 <code>NettyRuntime.availableProcessors() * 2</code>，也就是 <u>CPU可用核数 * 2</u>。</li></ul><p>因此使用默认构造函数创建 NioEventLoopGroup ，<code>nThreads</code> 参数即为 0，NioEventLoopGroup 内的 NioEventLoop 数量为 <u>CPU可用核数 * 2</u>。</p><br><h2 id="核心逻辑">2.2. 核心逻辑</h2><p>在 <a href="#NioEventLoopGroup%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">NioEventLoopGroup的构造函数 (点击跳转)</a> 小节中提到过，父类 MultithreadEventExecutorGroup 构造函数是 NioEventLoopGroup 构造函数调用链路中的核心逻辑所在，接下来直接看 MultithreadEventExecutorGroup 构造函数，源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MultithreadEventExecutorGroup</span> <span class="keyword">extends</span> <span class="title class_">AbstractEventExecutorGroup</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// NioEventLoopGroup 中保存 NioEventLoop 的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] children;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择器, 可以看做是负载均衡器, 用于从 children 集合中选取一个 NioEventLoop。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutorChooserFactory.EventExecutorChooser chooser;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, Object... args)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 没有指定线程池,则创建默认.</span></span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建内部的 eventLoop 数组,nThreads 默认为CPU核数*2</span></span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">EventExecutor</span>[nThreads];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对应 nThreads 数量的 eventLoop 对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建 eventLoop 对象,添加到 children 数组中</span></span><br><span class="line">                children[i] = newChild(executor, args);</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123; ... &#125; <span class="keyword">finally</span> &#123; ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Chooser 本质可以看成一个负载均衡器,用于选择一个内部的 eventLoop</span></span><br><span class="line">        chooser = chooserFactory.newChooser(children);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>line: 18 -&gt; 创建用于运行 NioEventLoop 的默认线程池。<br>如果没有指定线程池，则创建默认线程池(ThreadPerTaskExecutor)，NioEventLoopGroup 中所有的 NioEventLoop 都运行在这个线程池中。</p><p></p></li><li><p>line: 29 -&gt; 创建 NioEventLoop，调用子类实现的 <code>NioEventLoopGroup#newChild</code> 方法。</p><p></p></li><li><p>line: 35 -&gt; 创建 chooser。</p></li></ul><br><h1 id="创建-NioEventLoop">3. 创建 NioEventLoop</h1><p>以上，创建 NioEventLoop 的关键是 <code>MultithreadEventExecutorGroup#newChild</code> 抽象方法，NioEventLoopGroup 进行了具体实现，此处这里实际调用的是 <code>NioEventLoopGroup#newChild</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建对应 nThreads 数量的 eventLoop 对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 eventLoop 对象, 并添加到 children 数组中</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; ... &#125; <span class="keyword">finally</span> &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEventLoopGroup</span> <span class="keyword">extends</span> <span class="title class_">MultithreadEventLoopGroup</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> EventLoop <span class="title function_">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 以下都是用于构建 eventLoop 的参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// NIO工具类,SelectorProvider 使用了JDK的 SPI机制 来创建Selector、ServerSocketChannel、SocketChannel 等对象；</span></span><br><span class="line">        <span class="type">SelectorProvider</span> <span class="variable">selectorProvider</span> <span class="operator">=</span> (SelectorProvider) args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SelectStrategy 是 Netty 用来控制 eventLoop 轮询方式的策略,此处 args[0] = DefaultSelectStrategyFactory.INSTANCE；</span></span><br><span class="line">        <span class="type">SelectStrategyFactory</span> <span class="variable">selectStrategyFactory</span> <span class="operator">=</span> (SelectStrategyFactory) args[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池的任务拒绝策略,默认是抛出 RejectedExecutionException 异常；</span></span><br><span class="line">        <span class="type">RejectedExecutionHandler</span> <span class="variable">rejectedExecutionHandler</span> <span class="operator">=</span> (RejectedExecutionHandler) args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务队列工厂类,每一个EventLoop对象内部都会包含一个任务队列</span></span><br><span class="line">        <span class="comment">// 这个工厂类就是用来创建队列的,默认会创建一个Netty自定义线程安全的 MpscUnboundedArrayQueue 无锁队列。</span></span><br><span class="line">        <span class="type">EventLoopTaskQueueFactory</span> <span class="variable">taskQueueFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">EventLoopTaskQueueFactory</span> <span class="variable">tailTaskQueueFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">argsLength</span> <span class="operator">=</span> args.length;</span><br><span class="line">        <span class="keyword">if</span> (argsLength &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            taskQueueFactory = (EventLoopTaskQueueFactory) args[<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argsLength &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            tailTaskQueueFactory = (EventLoopTaskQueueFactory) args[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NioEventLoop</span>(<span class="built_in">this</span>, executor, selectorProvider,</span><br><span class="line">                selectStrategyFactory.newSelectStrategy(),</span><br><span class="line">                rejectedExecutionHandler, taskQueueFactory, tailTaskQueueFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>line: 25 -&gt; NioEventLoop 最重要的事情之一就是：通过 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>轮询注册其上的 Channel 感兴趣的 <u>I&#x2F;O就绪事件</u>，SelectStrategyFactory 用于指定轮询策略，默认是：<code>DefaultSelectStrategyFactory.INSTANCE</code> 。</p><br></li><li><p>line: 32 &amp; line: 33 -&gt; 关于 EventLoopTaskQueueFactory。<br>Netty 中的 NioEventLoop 主要工作是轮询注册其上所有 Channel 的 <u>I&#x2F;O就绪事件</u> 并处理。<br>除了这些主要的工作外，Netty 为了极致的压榨 NioEventLoop 的性能，还会让它执行一些异步任务。既然要执行异步任务，那么 NioEventLoop 中就需要队列来保存任务。<br>此处的 EventLoopTaskQueueFactory 就是用来创建队列，以保存 NioEventLoop 中待执行的异步任务。</p><br></li><li><p>关于异步任务<br>NioEventLoop 中的异步任务分为三类：</p><ul><li>普通任务(line: 32)：Netty 最主要执行的异步任务，存放在 <u>taskQueue(普通任务队列)</u> 中。</li><li>尾部任务(line: 33)：存放在 <u>tailTaskQueue(尾部任务队列)</u> 中，尾部任务不常用，定时任务和普通任务执行完后才会执行尾部任务。</li><li>定时任务：存放在 <u>scheduledTaskQueue(定时任务队列&#x2F;优先级队列)</u> 中。</li></ul><br></li><li><p>line: 43 -&gt; 调用 NioEventLoop 构造函数，创建 NioEventLoop。</p></li></ul><br><h2 id="NioEventLoop构造函数">3.1. NioEventLoop构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">                SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,</span><br><span class="line">                EventLoopTaskQueueFactory taskQueueFactory, EventLoopTaskQueueFactory tailTaskQueueFactory) &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent, executor, <span class="literal">false</span>, newTaskQueue(taskQueueFactory), newTaskQueue(tailTaskQueueFactory),</span><br><span class="line">            rejectedExecutionHandler);</span><br><span class="line">    <span class="built_in">this</span>.provider = ObjectUtil.checkNotNull(selectorProvider, <span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.selectStrategy = ObjectUtil.checkNotNull(strategy, <span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建 selector</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectorTuple</span> <span class="variable">selectorTuple</span> <span class="operator">=</span> openSelector();</span><br><span class="line">    <span class="built_in">this</span>.selector = selectorTuple.selector;</span><br><span class="line">    <span class="built_in">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>line: 4 -&gt; 向上调用父类构造函数。</p><p></p></li><li><p>line: 4 -&gt; <code>newTaskQueue(taskQueueFactory)</code> ，用于创建 NioEventLoop 内部的 <u>taskQueue(普通任务队列)</u> , 普通任务是 Netty 中最主要执行的异步任务。</p><p></p></li><li><p>line: 4 -&gt; <code>newTaskQueue(tailTaskQueueFactory)</code> ，用于创建 NioEventLoop 内部的 <u>tailTaskQueue(尾部任务队列)</u> , 尾部任务不常用, 主要是统计数据的场景。</p><p></p></li><li><p>line: 9 -&gt; 创建和优化 Selector <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 逻辑。</p></li></ul><br><h3 id="创建内部队列">3.1.1. 创建内部队列</h3><p>NioEventLoop 构造函数中的 <code>newTaskQueue</code> 方法用于创建内部队列；<br>在 NioEventLoop 的父类 SingleThreadEventLoop 中提供了一个静态变量 <code>DEFAULT_MAX_PENDING_TASKS</code> 用来指定 NioEventLoop 内任务队列的大小。<br>可以通过系统变量 <code>io.netty.eventLoop.maxPendingTasks</code> 进行设置，默认为 <code>Integer.MAX_VALUE</code>，即为无界队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SingleThreadEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventExecutor</span> <span class="keyword">implements</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_PENDING_TASKS</span> <span class="operator">=</span> Math.max(<span class="number">16</span>,</span><br><span class="line">            SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoop.maxPendingTasks&quot;</span>, Integer.MAX_VALUE));</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Runnable&gt; <span class="title function_">newTaskQueue</span><span class="params">(</span></span><br><span class="line"><span class="params">            EventLoopTaskQueueFactory queueFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queueFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> newTaskQueue0(DEFAULT_MAX_PENDING_TASKS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queueFactory.newTaskQueue(DEFAULT_MAX_PENDING_TASKS);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Runnable&gt; <span class="title function_">newTaskQueue0</span><span class="params">(<span class="type">int</span> maxPendingTasks)</span> &#123;</span><br><span class="line">        <span class="comment">// This event loop never calls takeTask()</span></span><br><span class="line">        <span class="keyword">return</span> maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.&lt;Runnable&gt;newMpscQueue()</span><br><span class="line">                : PlatformDependent.&lt;Runnable&gt;newMpscQueue(maxPendingTasks);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioEventLoop 中的异步任务队列的类型为 <code>MpscQueue</code>，它是由 <code>JCTools</code> 提供的一个高性能无锁队列，从命名前缀 <code>Mpsc</code> 可以看出，它适用于 <u>多生产者单消费者</u> 的场景，它支持多个生产者线程安全的访问队列，同一时刻只允许一个消费者线程读取队列中的元素。</p><br><h3 id="创建Selector">3.1.2. 创建Selector</h3><p>NioEventLoop 构造函数中 <code>openSelector()</code> 方法用于创建 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> ，而且 Netty 还会在 <code>openSelector()</code> 方法中对创建出来的 Selector <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 进行存储结构优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// java.nio.channels.Selector</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Selector unwrappedSelector;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> SelectorTuple <span class="title function_">openSelector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 JDK NIO 原生 Selector</span></span><br><span class="line">            unwrappedSelector = provider.openSelector();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; ... &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>line: 13 -&gt; 创建 Selector <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 。<br>SelectorProvider <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.spi.SelectorProvider，相当于一个工厂类，提供了对 java.nio.channels.ServerSocketChannel、java.nio.channels.SocketChannel、java.nio.channels.Selector 等创建方法。
">[2]</span></a></sup>会根据操作系统、JDK版本选择不同的 Selector <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 实现，Linux下会选择 <code>Epoll</code>，Mac下会选择 <code>Kqueue</code>。<br>注意，此时 unwrappedSelector 属性中存储的是 <u>JDK NIO 原生 Selector</u> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>，还没有被优化过。</li></ul><br><h3 id="优化NIO原生Selector">3.1.3. 优化NIO原生Selector</h3><p>在 NioEventLoop 中有一个优化开关 <code>DISABLE_KEY_SET_OPTIMIZATION</code>，通过系统变量 <code>io.netty.noKeySetOptimization</code> 指定，默认是开启的，表示需要对 <u>JDK NIO 原生 Selector</u> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">DISABLE_KEY_SET_OPTIMIZATION</span> <span class="operator">=</span></span><br><span class="line">        SystemPropertyUtil.getBoolean(<span class="string">&quot;io.netty.noKeySetOptimization&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> SelectorTuple <span class="title function_">openSelector</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 JDK NIO 原生 Selector</span></span><br><span class="line">            unwrappedSelector = provider.openSelector();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认是会优化的，否则直接返回 JDK NIO 原生 Selector</span></span><br><span class="line">        <span class="keyword">if</span> (DISABLE_KEY_SET_OPTIMIZATION) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SelectorTuple</span>(unwrappedSelector);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果优化开关 <code>DISABLE_KEY_SET_OPTIMIZATION</code> 是关闭的，那么直接返回没有优化过的 <u>JDK NIO 原生 Selector</u> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>。</p><p>不过注意，openSelector 方法并没有直接返回 Selector <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>，而是将 Selector 包装在 <code>NioEventLoop.SelectorTuple</code> 中返回的，主要是为了兼容下面 Netty 优化后的数据结构 <b>SelectedSelectionKeySet</b>。</p><p>以下是 Netty 优化 <u>JDK NIO 原生 Selector</u> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>的逻辑，总共分为四步：</p><ol><li>获取 SelectorImpl。</li><li>判断是否是 <u>JDK NIO 原生 Selector</u> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>。</li><li>替换 HashSet。</li><li>包装返回。</li></ol><p><br><br></p><h4 id="获取-SelectorImpl">3.1.3.1. 获取 SelectorImpl</h4><p>获取 <u>JDK NIO 原生 Selector</u> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>的抽象实现类, 即: <code>sun.nio.ch.SelectorImpl</code>，<u>JDK NIO 原生 Selector</u> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>的实现都继承于该抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> SelectorTuple <span class="title function_">openSelector</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取 JDK NIO 原生 Selector 抽象实现类, 即: sun.nio.ch.SelectorImpl</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">maybeSelectorImplClass</span> <span class="operator">=</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Class.forName(<span class="string">&quot;sun.nio.ch.SelectorImpl&quot;</span>, <span class="literal">false</span>,</span><br><span class="line">                        PlatformDependent.getSystemClassLoader());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable cause) &#123; ... &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sun.nio.ch.SelectorImpl</code> 部分源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SelectorImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO就绪的 SelectionKey</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;SelectionKey&gt; selectedKeys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册在该 Selector 上的所有 SelectionKey</span></span><br><span class="line">    <span class="keyword">protected</span> HashSet&lt;SelectionKey&gt; keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于向调用线程返回的 keys, 不可变</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;SelectionKey&gt; publicKeys;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当有IO就绪的 SelectionKey 时, 向调用线程返回, 只可删除其中元素，不可增加</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;SelectionKey&gt; publicSelectedKeys;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">SelectorImpl</span><span class="params">(SelectorProvider sp)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(sp);</span><br><span class="line">        keys = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;SelectionKey&gt;();</span><br><span class="line">        selectedKeys = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;SelectionKey&gt;();</span><br><span class="line">        <span class="keyword">if</span> (Util.atBugLevel(<span class="string">&quot;1.4&quot;</span>)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不可变</span></span><br><span class="line">            publicKeys = Collections.unmodifiableSet(keys);</span><br><span class="line">            <span class="comment">// 只可删除元素, 不可以增加</span></span><br><span class="line">            publicSelectedKeys = Util.ungrowableSet(selectedKeys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#D2691E">重点关注抽象类 <code>sun.nio.ch.SelectorImpl</code> 中的 <b>selectedKeys</b> 和 <b>publicSelectedKeys</b> 这两个字段，注意它们的类型都是 <code>HashSet</code> ，后面优化的就是这里</font>。</p><p><br><br></p><h4 id="判断是否是JDK-NIO-原生-Selector">3.1.3.2. 判断是否是JDK NIO 原生 Selector</h4><p>上面获取 <code>sun.nio.ch.SelectorImpl</code> 抽象实现类，用于判断由 SelectorProvider<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.spi.SelectorProvider，相当于一个工厂类，提供了对 java.nio.channels.ServerSocketChannel、java.nio.channels.SocketChannel、java.nio.channels.Selector 等创建方法。
">[2]</span></a></sup> 创建出来的 <code>java.nio.channels.Selector</code> 是否是 <b>JDK默认实现</b>。</p><p>因为 SelectorProvider<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.spi.SelectorProvider，相当于一个工厂类，提供了对 java.nio.channels.ServerSocketChannel、java.nio.channels.SocketChannel、java.nio.channels.Selector 等创建方法。
">[2]</span></a></sup> 可以自定义加载，因此创建出来的 <code>java.nio.channels.Selector</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>并不一定是 <u>JDK NIO 原生 Selector</u> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> SelectorTuple <span class="title function_">openSelector</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 只针对 JDK NIO 原生 Selector 的实现类进行优化。</span></span><br><span class="line">        <span class="keyword">if</span> (!(maybeSelectorImplClass <span class="keyword">instanceof</span> Class) ||</span><br><span class="line">            !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maybeSelectorImplClass <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> (Throwable) maybeSelectorImplClass;</span><br><span class="line">                logger.trace(<span class="string">&quot;failed to instrument a special java.util.Set into: &#123;&#125;&quot;</span>, unwrappedSelector, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SelectorTuple</span>(unwrappedSelector);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Netty 优化针对的是 <u>JDK NIO 原生 Selector</u> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>，如果 <code>sun.nio.ch.SelectorImpl</code> 类不是 <code>java.nio.channels.Selector</code> 的父类，说明是自定义加载的，不用优化直接返回，中断后续优化步骤。</p><p><br><br></p><h4 id="替换HashSet">3.1.3.3. 替换HashSet</h4><p>创建 <code>SelectedSelectionKeySet</code>，通过反射替换掉 <code>sun.nio.ch.SelectorImpl</code> 类中 <b>selectedKeys</b> 和 <b>publicSelectedKeys</b> 这两个属性的默认 <code>HashSet</code> 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> SelectorTuple <span class="title function_">openSelector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SelectedSelectionKeySet 是 netty 优化后的数据结构</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SelectedSelectionKeySet</span> <span class="variable">selectedKeySet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SelectedSelectionKeySet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">maybeException</span> <span class="operator">=</span> AccessController.doPrivileged((PrivilegedAction)() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 用反射的方式, 把 Selector 内部的 selectedKeys 和 publicSelectedKeys ,</span></span><br><span class="line">                <span class="comment">// 替换成 netty 优化后的 SelectedSelectionKeySet</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">selectedKeysField</span> <span class="operator">=</span> selectorImplClass.getDeclaredField(<span class="string">&quot;selectedKeys&quot;</span>);</span><br><span class="line">                <span class="type">Field</span> <span class="variable">publicSelectedKeysField</span> <span class="operator">=</span> selectorImplClass.getDeclaredField(<span class="string">&quot;publicSelectedKeys&quot;</span>);</span><br><span class="line">                ...</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> ReflectionUtil.trySetAccessible(selectedKeysField, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cause;</span><br><span class="line">                &#125;</span><br><span class="line">                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cause;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                selectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; ... &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>line: 4 -&gt; 被 Netty 优化过的 Selector <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup>，其中 <code>publicKeys</code> 和 <code>publicSelectedKeys</code> 属性的类型由 HashSet 被替换成了 SelectedSelectionKeySet。</p><p></p></li><li><p>line: 16 ~ line 17 -&gt; 通过反射获取 <code>sun.nio.ch.SelectorImpl</code> 类中 <code>selectedKeys</code> 和 <code>publicSelectedKeys</code> 。</p><p></p></li><li><p>line: 19 ~ line: 29 -&gt; 通过反射的方式，用 <code>SelectedSelectionKeySet</code> 替换掉 <code>HashSet</code> 实现的<code>SelectorImpl#selectedKeys</code> 和 <code>SelectorImpl#publicSelectedKeys</code> 。</p><p></p></li></ul><hr><p>为什么要用 <code>SelectedSelectionKeySet</code> 替换掉原来的 <code>HashSet</code> 呢?</p><p>这就涉及到对 <code>HashSet</code> 类型的两种集合操作:</p><ul><li><p><font color="#FF4500">插入操作</font>：<code>Selector</code><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 监听到 <u>IO就绪</u> 的 <code>java.nio.channels.SelectionKey</code> 后, 会将这些 <code>java.nio.channels.SelectionKey</code> 插入到 <code>sun.nio.ch.SelectorImpl#selectedKeys</code> 集合中。</p><p></p></li><li><p><font color="#FF4500">遍历操作</font>：NioEventLoop 内的工作线程会遍历 <code>sun.nio.ch.SelectorImpl#selectedKeys</code> 集合, 获取 <u>I&#x2F;O就绪</u> 的 SocketChannel, 并处理 SocketChannel 上的 <u>I&#x2F;O就绪事件</u>。</p></li></ul><p></p><p>翻阅源码， <code>HashSet</code> 的底层数据结构是一个 <u>Hash表</u>，因此存在 <u>Hash冲突</u> 的可能，所以会导致同样是插入和遍历操作, <code>HashSet</code> 的性能不如数组好。还有一个重要原因是，数组可以利用CPU缓存的优势提高遍历效率。</p><p><code>SelectedSelectionKeySet</code> 内部维护一个数组，有一个变量 size 标识数组的逻辑长度。<br>每次 add 时，会把元素添加到数组的逻辑尾部，然后逻辑长度+1，当逻辑长度等于物理长度时，数组扩容。<br>相比于 HashSet 的实现，这种方式不需要考虑哈希冲突，是真正的 O(1) 时间复杂度。而调用 iterator 时相当于遍历数组，也比遍历 HashSet 更加高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SelectedSelectionKeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;SelectionKey&gt; &#123;</span><br><span class="line">    SelectionKey[] keys;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    SelectedSelectionKeySet() &#123; keys = <span class="keyword">new</span> <span class="title class_">SelectionKey</span>[<span class="number">1024</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(SelectionKey o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        keys[size++] = o;</span><br><span class="line">        <span class="keyword">if</span> (size == keys.length) &#123; increaseCapacity(); &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;SelectionKey&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;SelectionKey&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> idx;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; <span class="keyword">return</span> idx &lt; size; &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> SelectionKey <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasNext()) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(); &#125;</span><br><span class="line">                <span class="keyword">return</span> keys[idx++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br></p><h4 id="包装返回">3.1.3.4. 包装返回</h4><p>完成 <code>SelectorImpl#selectedKeys</code> 和 <code>SelectorImpl#publicSelectedKeys</code> 属性的类型的替换后，将优化 SelectedSelectionKeySet 类型的 <code>selectedKeySet</code> 设置到 <code>NioEventLoop#selectedKeys</code> 属性中保存，并将结果包装成 <code>NioEventLoop.SelectorTuple</code> 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NioEventLoop</span> <span class="keyword">extends</span> <span class="title class_">SingleThreadEventLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> SelectorTuple <span class="title function_">openSelector</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        selectedKeys = selectedKeySet;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SelectorTuple</span>(unwrappedSelector,</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">SelectedSelectionKeySetSelector</span>(unwrappedSelector, selectedKeySet));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上，Netty 为了优化对 <code>SelectorImpl#selectedKeys</code> 和 <code>SelectorImpl#publicSelectedKeys</code> 属性的集合操作性能, 使用 <code>SelectedSelectionKeySet</code> 来替换掉 <code>sun.nio.ch.SelectorImpl</code> 类中 <b>selectedKeys</b> 和 <b>publicSelectedKeys</b> 这两个字段的默认 <code>HashSet</code> 实现。</p><br><h2 id="父类构造函数">3.2. 父类构造函数</h2><h3 id="SingleThreadEventLoop">3.2.1. SingleThreadEventLoop</h3><p>NioEventLoop 父类 SingleThreadEventLoop 的构造函数中也没有做什么处理，继续向上调用父类构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, Executor executor, <span class="type">boolean</span> addTaskWakesUp,</span></span><br><span class="line"><span class="params">                                Queue&lt;Runnable&gt; taskQueue, Queue&lt;Runnable&gt; tailTaskQueue, </span></span><br><span class="line"><span class="params">                                RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;</span><br><span class="line">    <span class="comment">// addTaskWakesUp 默认为false, 用于标记 添加的任务是否会唤醒线程</span></span><br><span class="line">    <span class="comment">// 调用父类</span></span><br><span class="line">    <span class="built_in">super</span>(parent, executor, addTaskWakesUp, taskQueue, rejectedExecutionHandler);</span><br><span class="line">    tailTasks = ObjectUtil.checkNotNull(tailTaskQueue, <span class="string">&quot;tailTaskQueue&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>line: 6 -&gt; addTaskWakesUp 参数默认为 false, 用于标记 添加的任务是否会唤醒线程</p><blockquote><p>单独看的话, SingleThreadEventLoop 类负责对 <u>tailTaskQueue(尾部任务队列)</u> 进行管理, 并且提供向 NioEventLoop 注册 Channel 的行为。</p></blockquote><br><h3 id="SingleThreadEventExecutor">3.2.2. SingleThreadEventExecutor</h3><p>SingleThreadEventExecutor 中也没有什么处理，大部分向上透传的参数都保存在了 SingleThreadEventExecutor 类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,<span class="type">boolean</span> addTaskWakesUp,</span></span><br><span class="line"><span class="params">                                    Queue&lt;Runnable&gt; taskQueue,RejectedExecutionHandler rejectedHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="built_in">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="built_in">this</span>.maxPendingTasks = DEFAULT_MAX_PENDING_EXECUTOR_TASKS;</span><br><span class="line">    <span class="built_in">this</span>.executor = ThreadExecutorMap.apply(executor, <span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.taskQueue = ObjectUtil.checkNotNull(taskQueue, <span class="string">&quot;taskQueue&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">&quot;rejectedHandler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单独看的话，SingleThreadEventExecutor 类主要负责对 <u>taskQueue(普通任务队列)</u> 的管理, 以及异步任务的执行, NioEventLoop 中工作线程的启停。</p></blockquote><br><h1 id="创建chooser">4. 创建chooser</h1><p>chooser 可以看做是负载均衡器, 用于从 children 集合中选取一个 NioEventLoop。</p><p>从 <a href="#%E7%A1%AE%E5%AE%9A%E5%88%9B%E5%BB%BANioEventLoop%E6%95%B0%E9%87%8F">确定创建NioEventLoop数量(点击跳转)</a> 小节中知道，NioEventLoopGroup 中默认会创建 <u>CPU可用核数 * 2</u> 个 NioEventLoop，当客户端连接完成三次握手后，parentGroup 会创建 NioSocketChannel，并将 NioSocketChannel 注册到 childGroup 中某个 NioEventLoop 的 Selector<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。
">[1]</span></a></sup> 上，那么具体注册到childGroup 的哪个 NioEventLoop 上呢？</p><p>这个选取策略就是由 chooserFactory 来创建的，默认为 DefaultEventExecutorChooserFactory。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建对应 nThreads 数量的 eventLoop 对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 eventLoop 对象,添加到 children 数组中</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125; <span class="keyword">finally</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Chooser 本质可以看成一个负载均衡器,用于选择一个内部的 eventLoop</span></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 newChooser 方法中，会根据 NioEventLoop 的数量选择不同的 chooser 实现，选择的依据是数量是否是2的幂次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.concurrent.DefaultEventExecutorChooserFactory#newChooser</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> EventExecutorChooser <span class="title function_">newChooser</span><span class="params">(EventExecutor[] executors)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据待绑定的 executor 数量是否是2的幂次方,选择不同的&#x27;选择器实现&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PowerOfTwoEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GenericEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="NioEventLoop创建流程图">5. NioEventLoop创建流程图</h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/posts/15160/NioEventLoop的创建.png" alt="NioEventLoop的创建(新标签页中打开可放大图片)" style="zoom:80%"><hr><p>以上是创建 NioEventLoop 的过程，NioEventLoop 的启动和运行，在下篇 <a href="/posts/45721.html" title="Netty_NioEventLoop启动和运行">Netty_NioEventLoop启动和运行</a> 中梳理分析。</p><br><h1 id="Reference">6. Reference</h1><ul><li><a target="_blank" rel="noopener" href="https://www.tpvlog.com/article/356#menu_1">透彻理解Java网络编程（十一）——Netty原理：EventLoopGroup和EventLoop</a></li><li><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/04%20%E4%BA%8B%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%B1%82%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%20EventLoop%20%E6%98%AF%20Netty%20%E7%9A%84%E7%B2%BE%E9%AB%93%EF%BC%9F.md">04 事件调度层：为什么 EventLoop 是 Netty 的精髓？</a></li><li><a target="_blank" rel="noopener" href="http://www.linkedkeeper.com/1695.html">Netty 核心源码解读 —— EventLoop 篇</a></li><li><a target="_blank" rel="noopener" href="http://huzb.me/2019/09/27/netty%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94NioEventLoop/">Netty 源码浅析——NioEventLoop</a></li><li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247483907&idx=1&sn=084c470a8fe6234c2c9461b5f713ff30&chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&scene=21#wechat_redirect">聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)</a></li></ul><br><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0;margin-left:40px"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px;margin-left:-40px">1.</span><span style="display:inline-block;vertical-align:top;margin-left:10px">java.nio.channels.Selector(多路复用器) 可以看成是操作系统底层中 select/epoll/poll 多路复用函数的Java包装类。只要 Selector 监听的任一一个 Channel 上有事件发生，就可以通过 Selector.select() 方法监测到，并且使用 SelectedKeys 可以得到对应的 Channel，然后对它们执行相应的I/O操作。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px;margin-left:-40px">2.</span><span style="display:inline-block;vertical-align:top;margin-left:10px">java.nio.channels.spi.SelectorProvider，相当于一个工厂类，提供了对 java.nio.channels.ServerSocketChannel、java.nio.channels.SocketChannel、java.nio.channels.Selector 等创建方法。<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><link rel="stylesheet" href="/css/folder.css" type="text/css"><script src="/js/folder.js" type="text/javascript" async></script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></div><div id="btn-catalog" class="btn-catalog"><i class="iconfont icon-catalog"></i></div><div class="post-catalog hidden" id="catalog"><div class="title">目录</div><div class="catalog-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-text">1. 概览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NioEventLoopGroup%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2. NioEventLoopGroup的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%88%9B%E5%BB%BANioEventLoop%E6%95%B0%E9%87%8F"><span class="toc-text">2.1. 确定创建NioEventLoop数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-text">2.2. 核心逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-NioEventLoop"><span class="toc-text">3. 创建 NioEventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NioEventLoop%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">3.1. NioEventLoop构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E9%83%A8%E9%98%9F%E5%88%97"><span class="toc-text">3.1.1. 创建内部队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BASelector"><span class="toc-text">3.1.2. 创建Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96NIO%E5%8E%9F%E7%94%9FSelector"><span class="toc-text">3.1.3. 优化NIO原生Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-SelectorImpl"><span class="toc-text">3.1.3.1. 获取 SelectorImpl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AFJDK-NIO-%E5%8E%9F%E7%94%9F-Selector"><span class="toc-text">3.1.3.2. 判断是否是JDK NIO 原生 Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2HashSet"><span class="toc-text">3.1.3.3. 替换HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E8%BF%94%E5%9B%9E"><span class="toc-text">3.1.3.4. 包装返回</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">3.2. 父类构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SingleThreadEventLoop"><span class="toc-text">3.2.1. SingleThreadEventLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SingleThreadEventExecutor"><span class="toc-text">3.2.2. SingleThreadEventExecutor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAchooser"><span class="toc-text">4. 创建chooser</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NioEventLoop%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">5. NioEventLoop创建流程图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-text">6. Reference</span></a></li></ol></div></div><script src="/js/catalog.js"></script><div class="comments-container"></div></div><div class="footer"><div class="social"><ul><li><a title="github" target="_blank" rel="noopener" href="https://github.com/Simba-cheng"><i class="iconfont icon-github"></i></a></li><li><a title="rss" href="/atom.xml"><i class="iconfont icon-rss"></i></a></li></ul></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a></div><div class="footer-more"><a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a></div><div class="footer-views">本站总访问量<span id="busuanzi_value_site_pv"></span>次 本文总阅读量<span id="busuanzi_value_page_pv"></span>次 本站访客数<span id="busuanzi_value_site_uv"></span>人</div></div></div><div class="tools-bar"><div class="back-to-top tools-bar-item hidden"><a href="javascript: void(0)"><i class="iconfont icon-chevronup"></i></a></div><script src="/js/backtotop.js"></script><div class="search-icon tools-bar-item" id="search-icon"><a href="javascript: void(0)"><i class="iconfont icon-search"></i></a></div><div class="search-overlay hidden"><div class="search-content" tabindex="0"><div class="search-title"><span class="search-icon-input"><a href="javascript: void(0)"><i class="iconfont icon-search"></i> </a></span><input type="text" class="search-input" id="search-input" placeholder="搜索..."> <span class="search-close-icon" id="search-close-icon"><a href="javascript: void(0)"><i class="iconfont icon-close"></i></a></span></div><div class="search-result" id="search-result"></div></div></div><script type="text/javascript">var inputArea=document.querySelector("#search-input"),searchOverlayArea=document.querySelector(".search-overlay");function openOrHideSearchContent(){searchOverlayArea.classList.contains("hidden")?(searchOverlayArea.classList.remove("hidden"),document.body.classList.add("hidden")):(searchOverlayArea.classList.add("hidden"),document.body.classList.remove("hidden"))}function blurSearchContent(e){e.target===searchOverlayArea&&openOrHideSearchContent()}inputArea.onclick=function(){getSearchFile(),this.onclick=null},inputArea.onkeydown=function(){if(13==event.keyCode)return!1},document.querySelector("#search-icon").addEventListener("click",openOrHideSearchContent,!1),document.querySelector("#search-close-icon").addEventListener("click",openOrHideSearchContent,!1),searchOverlayArea.addEventListener("click",blurSearchContent,!1);var searchFunc=function(e,t,n){"use strict";var r=document.getElementById(t),a=document.getElementById(n);a.innerHTML="<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>",$.ajax({url:e,dataType:"xml",success:function(e){var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get();a.innerHTML="",r.addEventListener("input",function(){var u='<ul class="search-result-list">',h=this.value.trim().toLowerCase().split(/[\s\-]+/);if(a.innerHTML="",!(this.value.trim().length<=0)){if(t.forEach(function(e){var n,r,a=!0,t=(e.title&&""!==e.title.trim()||(e.title="Untitled"),e.title.trim()),c=t.toLowerCase(),s=e.content.trim().replace(/<[^>]+>/g,""),i=s.toLowerCase(),e=e.url,l=-1,o=-1;""!==i?h.forEach(function(e,t){n=c.indexOf(e),l=i.indexOf(e),n<0&&l<0?a=!1:(l<0&&(l=0),0==t&&(o=l))}):a=!1,a&&(u+="<li><a href='"+e+"' class='search-result-title'>"+t+"</a>",0<=o&&(e=o+80,(e=0==(t=(t=o-20)<0?0:t)?100:e)>s.length&&(e=s.length),r=s.substr(t,e),h.forEach(function(e){var t=new RegExp(e,"gi");r=r.replace(t,'<span class="search-keyword">'+e+"</span>")}),u+='<p class="search-result-abstract">'+r+"...</p>"),u+="</li>")}),-1===(u+="</ul>").indexOf("<li>"))return a.innerHTML="<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";a.innerHTML=u}})},error:function(e,t,n){a.innerHTML="",404===e.status?a.innerHTML="<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>":a.innerHTML="<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>"}}),$(document).on("click","#search-close-icon",function(){$("#search-input").val(""),$("#search-result").html("")})},getSearchFile=function(){searchFunc("/search.xml","search-input","search-result")}</script><div class="tools-bar-item theme-icon" id="switch-color-scheme"><a href="javascript: void(0)"><i id="theme-icon" class="iconfont icon-moon"></i></a></div><script src="/js/colorscheme.js"></script><div class="share-icon tools-bar-item"><a href="javascript: void(0)" id="share-icon"><i class="iconfont iconshare"></i></a><div class="share-content hidden"><a class="share-item" href="https://twitter.com/intent/tweet?text=' + Netty_NioEventLoop%E5%88%9B%E5%BB%BA + '&url=' + https%3A%2F%2Fsimba-cheng.github.io%2Fposts%2F15160.html + '" target="_blank" title="Twitter"><i class="iconfont icon-twitter"></i> </a><a class="share-item" href="https://www.facebook.com/sharer.php?u=https://simba-cheng.github.io/posts/15160.html" target="_blank" title="Facebook"><i class="iconfont icon-facebooksquare"></i></a></div></div><script src="/js/shares.js"></script></div></div><script src="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/js/index.js"></script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a=c[o],i=function(){c=c.filter(function(t){return a!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(a)};(t=a).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,n=t.getAttribute("data-original"),e.onload=function(){t.src=n,t.removeAttribute("data-original"),i()},t.src!==n&&(e.src=n))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this)</script><script src="/js/markmap.js"></script></body></html>